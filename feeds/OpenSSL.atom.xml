<?xml version="1.0" encoding="utf-8"?> 
<feed xmlns="http://www.w3.org/2005/Atom" xml:lang="en">
 <title type="text">Lost in Transaction: A neophyte explores Bitcoin: Posts tagged 'OpenSSL'</title>
 <link rel="self" href="http://www.lostintransaction.com/feeds/OpenSSL.atom.xml" />
 <link href="http://www.lostintransaction.com/tags/OpenSSL.html" />
 <id>urn:http-www-lostintransaction-com:-tags-OpenSSL-html</id>
 <updated>2014-03-15T04:09:45Z</updated>
 <entry>
  <title type="text">Converting a Bitcoin Public Key to a (Hex) Address</title>
  <link rel="alternate" href="http://www.lostintransaction.com/blog/2014/03/15/converting-a-bitcoin-public-key-to-a-hex-address/?utm_source=OpenSSL&amp;utm_medium=Atom" />
  <id>urn:http-www-lostintransaction-com:-blog-2014-03-15-converting-a-bitcoin-public-key-to-a-hex-address</id>
  <published>2014-03-15T04:09:45Z</published>
  <updated>2014-03-15T04:09:45Z</updated>
  <author>
   <name>The Unknown Author</name></author>
  <content type="html">
&lt;html&gt;&lt;img src="http://www.lostintransaction.com/img/1x1.gif?utm_source=OpenSSL&amp;amp;utm_medium=Atom&amp;amp;utm_campaign=%2Fblog%2F2014%2F03%2F15%2Fconverting-a-bitcoin-public-key-to-a-hex-address%2F" height="1" width="1" /&gt;
 &lt;p&gt;In a previous post, we &lt;a href="lit:pubfrompriv"&gt;derived a Bitcoin public key from a private key&lt;/a&gt;. This post explores how to convert that public key into a Bitcoin address (in hexadecimal notation). I&amp;rsquo;ll be using &lt;a href="http://racket-lang.org"&gt;the Racket language&lt;/a&gt; in this post.&lt;/p&gt;
 &lt;p&gt;C is great for many programming tasks but sometimes it&amp;rsquo;s nice to use a higher-level language that automatically handles things like arbitrary-precision arithmetic and memory management. &lt;a href="http://racket-lang.org"&gt;Racket&lt;/a&gt;, a LISP dialect, has linguistic support for these features (and more) and I enjoy using it to experiment with Bitcoin.&lt;/p&gt;
 &lt;p&gt;Unfortunately, Racket doesn&amp;rsquo;t have a complete crypto library. It does have, however, an &lt;a href="http://docs.racket-lang.org/foreign/index.html" title="Racket FFI"&gt;FFI&lt;/a&gt; that enables Racket code to directly call C functions. Let&amp;rsquo;s first create Racket bindings for two important hashing functions used by Bitcoin, &lt;a href="http://en.wikipedia.org/wiki/SHA-2" title="Wikipedia: SHA-2"&gt;SHA&amp;ndash;256&lt;/a&gt; and &lt;a href="http://en.wikipedia.org/wiki/RIPEMD" title="Wikipedia: RIPEMD"&gt;RIPEMD&amp;ndash;160&lt;/a&gt;.&lt;/p&gt;
 &lt;h3 id="ffi-lib"&gt;&lt;code&gt;ffi-lib&lt;/code&gt;&lt;/h3&gt;
 &lt;p&gt;The &lt;a href="http://docs.racket-lang.org/foreign/Loading_Foreign_Libraries.html?q=ffi-lib#%28def._%28%28lib._ffi%2Funsafe..rkt%29._ffi-lib%29%29" title="Racket docs: ffi-lib"&gt;&lt;code&gt;ffi-lib&lt;/code&gt;&lt;/a&gt; function creates a Racket value through which programmers can access functions in the specified C library. For example, the following code evaluates to a Racket value for the OpenSSL &lt;code&gt;libcrypto&lt;/code&gt; library:&lt;/p&gt;
 &lt;pre class="brush: racket"&gt;&lt;code&gt;(ffi-lib '(so "libcrypto") '("" "1.0.1e" "1.0.0" "1.0" "0.9.8b" "0.9.8" "0.9.7"))&lt;/code&gt;&lt;/pre&gt;
 &lt;p&gt;Here the first argument to &lt;code&gt;ffi-lib&lt;/code&gt; specifies a dynamic C library and the second argument is a list of acceptable version numbers. (Check the &lt;a href="http://docs.racket-lang.org/foreign/Loading_Foreign_Libraries.html?q=ffi-lib#%28def._%28%28lib._ffi%2Funsafe..rkt%29._ffi-lib%29%29" title="Racket docs: ffi-lib"&gt;&lt;code&gt;ffi-lib&lt;/code&gt; documentation&lt;/a&gt; for other possible use cases.)&lt;/p&gt;
 &lt;p&gt;The standard Racket distribution pre-defines an identifier (also named &lt;code&gt;librypto&lt;/code&gt;) that is bound to the &lt;code&gt;libcrypto&lt;/code&gt; library (Racket comes with wrapper functions for some &lt;code&gt;libcrypto&lt;/code&gt; C functions, but not for &lt;code&gt;SHA256&lt;/code&gt; or &lt;code&gt;RIPEMD160&lt;/code&gt;).&lt;/p&gt;
 &lt;h3 id="get-ffi-obj"&gt;&lt;code&gt;get-ffi-obj&lt;/code&gt;&lt;/h3&gt;
 &lt;p&gt;Let&amp;rsquo;s create a Racket wrapper function for the &lt;a href="http://git.openssl.org/gitweb/?p=openssl.git;a=blob;f=crypto/sha/sha.h;h=8a6bf4bbbb1dbef37869fc162ce1c2cacfebeb1d;hb=46ebd9e3bb623d3c15ef2203038956f3f7213620#l155" title="OpenSSL source: crypto/sha/sha.h"&gt;&lt;code&gt;SHA256&lt;/code&gt; C function&lt;/a&gt;. Here&amp;rsquo;s the header:&lt;/p&gt;
 &lt;pre class="brush: C"&gt;&lt;code&gt;unsigned char *SHA256( const unsigned char *d, size_t n, unsigned char *md );&lt;/code&gt;&lt;/pre&gt;
 &lt;p&gt;To create a Racket wrapper function, we use &lt;a href="http://docs.racket-lang.org/foreign/Loading_Foreign_Libraries.html?q=get-ffi-obj#%28def._%28%28lib._ffi%2Funsafe..rkt%29._get-ffi-obj%29%29" title="Racket docs: get-ffi-obj"&gt;&lt;code&gt;get-ffi-obj&lt;/code&gt;&lt;/a&gt;. Here&amp;rsquo;s one possible definition of a &lt;code&gt;sha256&lt;/code&gt; Racket function that calls the &lt;code&gt;SHA256&lt;/code&gt; C function:&lt;/p&gt;
 &lt;pre class="brush: racket"&gt;&lt;code&gt;(define SHA256-DIGEST-LEN 32)

(define sha256
  (get-ffi-obj
    'SHA256 libcrypto
    (_fun [input     : _bytes]
          [input-len : _ulong = (bytes-length input)]
          [output    : (_bytes o SHA256-DIGEST-LEN)]
          -&amp;gt; (_bytes o SHA256-DIGEST-LEN))))&lt;/code&gt;&lt;/pre&gt;
 &lt;p&gt;The first argument to &lt;code&gt;get-ffi-obj&lt;/code&gt; is the name of the C function and the second argument is the library value that we created earlier with &lt;code&gt;ffi-lib&lt;/code&gt;. The third argument is the type, which specifies how to mediate between Racket and C values. &lt;a href="http://docs.racket-lang.org/foreign/foreign_procedures.html?q=_fun#%28form._%28%28lib._ffi%2Funsafe..rkt%29.__fun%29%29" title="Racket docs: _fun"&gt;&lt;code&gt;_fun&lt;/code&gt;&lt;/a&gt; is the function type and in this case the function has three arguments (each delimited with brackets by convention).&lt;/p&gt;
 &lt;p&gt;Examining the types of the arguments:&lt;/p&gt;
 &lt;ol&gt;
  &lt;li&gt;
   &lt;p&gt;The first argument to the &lt;code&gt;SHA256&lt;/code&gt; C function is an array of input bytes. Accordingly, we give &lt;code&gt;get-ffi-obj&lt;/code&gt; a &lt;code&gt;_bytes&lt;/code&gt; type for this argument.&lt;/p&gt;&lt;/li&gt;
  &lt;li&gt;
   &lt;p&gt;The second argument is the length of the input byte array. The &lt;code&gt;=&lt;/code&gt; and the following expression describe how to calculate this argument automatically. Thus a caller of the &lt;code&gt;sha256&lt;/code&gt; Racket function need not provide this argument.&lt;/p&gt;&lt;/li&gt;
  &lt;li&gt;
   &lt;p&gt;The third argument is the output byte array. The &lt;code&gt;o&lt;/code&gt; indicates a return pointer and is followed by the expected length of the output array, which should be 32 bytes here. We define a constant &lt;code&gt;SHA256-DIGEST-LEN&lt;/code&gt; which is analogous to &lt;a href="http://git.openssl.org/gitweb/?p=openssl.git;a=blob;f=crypto/sha/sha.h;h=8a6bf4bbbb1dbef37869fc162ce1c2cacfebeb1d;hb=46ebd9e3bb623d3c15ef2203038956f3f7213620#l133" title="OpenSSL source: crypto/sha/sha.h"&gt;the &lt;code&gt;SHA256_DIGEST_LENGTH&lt;/code&gt; constant&lt;/a&gt; in the C library.&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;
 &lt;h3 id="all-together"&gt;All Together&lt;/h3&gt;
 &lt;p&gt;Here&amp;rsquo;s some code defining a Racket module that exports functions named &lt;code&gt;sha256&lt;/code&gt; and &lt;code&gt;ripemd160&lt;/code&gt;. Note that the functions that call directly to the C functions are now named &lt;code&gt;sha256/bytes&lt;/code&gt; and &lt;code&gt;ripemd160/bytes&lt;/code&gt;, and these functions consume and produce bytes. We additionally define &lt;code&gt;sha256&lt;/code&gt; and &lt;code&gt;ripemd160&lt;/code&gt; functions which have optional keyword arguments for conversion of the input and output. These functions consume and produce hexadecimal strings by default.&lt;/p&gt;
 &lt;pre class="brush: racket"&gt;&lt;code&gt;#lang racket/base
(require ffi/unsafe openssl/libcrypto)
(require (only-in openssl/sha1 hex-string-&amp;gt;bytes
                               bytes-&amp;gt;hex-string))
(provide (all-defined-out))

(define SHA256-DIGEST-LEN 32)
(define RIPEMD160-DIGEST-LEN 20)

; from crypto/sha/sha.h:
;   unsigned char *SHA256(const unsigned char *d, size_t n, unsigned char *md);
(define sha256/bytes
  (get-ffi-obj
  'SHA256 libcrypto
  (_fun [input     : _bytes]
        [input-len : _ulong = (bytes-length input)]
        [output    : (_bytes o SHA256-DIGEST-LEN)]
        -&amp;gt; (_bytes o SHA256-DIGEST-LEN))))

(define (sha256 input #:convert-input  [input-&amp;gt;bytes hex-string-&amp;gt;bytes]
                      #:convert-output [bytes-&amp;gt;output bytes-&amp;gt;hex-string])
  (bytes-&amp;gt;output (sha256/bytes (input-&amp;gt;bytes input))))

; from crypto/ripemd/ripemd.h
;   unsigned char *RIPEMD160(const unsigned char *d, size_t n, unsigned char *md);
(define ripemd160/bytes
  (get-ffi-obj
  'RIPEMD160 libcrypto
  (_fun [input     : _bytes]
        [input-len : _ulong = (bytes-length input)]
        [output    : (_bytes o RIPEMD160-DIGEST-LEN)]
        -&amp;gt; (_bytes o RIPEMD160-DIGEST-LEN))))
       
(define (ripemd160 input #:convert-input  [input-&amp;gt;bytes hex-string-&amp;gt;bytes]
                         #:convert-output [bytes-&amp;gt;output bytes-&amp;gt;hex-string])
  (bytes-&amp;gt;output (ripemd160/bytes (input-&amp;gt;bytes input))))&lt;/code&gt;&lt;/pre&gt;
 &lt;h3 id="testing"&gt;Testing&lt;/h3&gt;
 &lt;p&gt;To test our wrapper functions, let&amp;rsquo;s see if we can duplicate &lt;a href="https://en.bitcoin.it/wiki/Technical_background_of_version_1_Bitcoin_addresses" title="Bitcoin Wiki: Technical background of version 1 Bitcoin addresses"&gt;this example from the Bitcoin wiki&lt;/a&gt;, which shows how to convert a Bitcoin private key into a public address. We covered &lt;a href="http://www.lostintransaction.com/blog/2014/03/14/deriving-a-bitcoin-public-key-from-a-private-key/" title="Deriving a Bitcoin Public Key From a Private Key"&gt;how to derive a public key from a private key&lt;/a&gt; in a previous post, so we start with the public key here.&lt;/p&gt;
 &lt;p&gt;For ease of comparison, here&amp;rsquo;s the sequence of expected hashes, copied from the Bitcoin wiki example:&lt;/p&gt;
 &lt;ol&gt;
  &lt;li&gt;public key: &lt;code&gt;0450863AD64A87AE8A2FE83C1AF1A8403CB53F53E486D8511DAD8A04887E5B23522CD470243453A299FA9E77237716103ABC11A1DF38855ED6F2EE187E9C582BA6&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;SHA&amp;ndash;256: &lt;code&gt;600FFE422B4E00731A59557A5CCA46CC183944191006324A447BDB2D98D4B408&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;RIPEMD&amp;ndash;160: &lt;code&gt;010966776006953D5567439E5E39F86A0D273BEE&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;prepend &lt;code&gt;0x00&lt;/code&gt;: &lt;code&gt;00010966776006953D5567439E5E39F86A0D273BEE&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;SHA&amp;ndash;256: &lt;code&gt;445C7A8007A93D8733188288BB320A8FE2DEBD2AE1B47F0F50BC10BAE845C094&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;SHA&amp;ndash;256 (checksum is first 4 bytes): &lt;code&gt;D61967F63C7DD183914A4AE452C9F6AD5D462CE3D277798075B107615C1A8A30&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;checksum + #4 = (hex) address: &lt;code&gt;00010966776006953D5567439E5E39F86A0D273BEED61967F6&lt;/code&gt;&lt;/li&gt;&lt;/ol&gt;
 &lt;p&gt;We can use &lt;a href="http://docs.racket-lang.org/guide/intro.html?q=repl#%28tech._repl%29" title="Interacting with Racket"&gt;the Racket REPL&lt;/a&gt;, and the code above (which I saved to a file &lt;code&gt;crypto.rkt&lt;/code&gt;) to get the same results:&lt;/p&gt;
 &lt;pre&gt;&lt;code&gt;$ racket
Welcome to Racket v6.0.0.3.
-&amp;gt; (require "crypto.rkt")
-&amp;gt; (define pub-key "0450863AD64A87AE8A2FE83C1AF1A8403CB53F53E486D8511DAD8A04887E5B23522CD470243453A299FA9E77237716103ABC11A1DF38855ED6F2EE187E9C582BA6")
-&amp;gt; (sha256 pub-key)
"600ffe422b4e00731a59557a5cca46cc183944191006324a447bdb2d98d4b408"
-&amp;gt; (ripemd160 (sha256 pub-key))
"010966776006953d5567439e5e39f86a0d273bee"
-&amp;gt; (define hash160 (ripemd160 (sha256 pub-key)))
-&amp;gt; (define hash160/extended (string-append "00" hash160))
-&amp;gt; (sha256 hash160/extended)
"445c7a8007a93d8733188288bb320a8fe2debd2ae1b47f0f50bc10bae845c094"
-&amp;gt; (sha256 (sha256 hash160/extended))
"d61967f63c7dd183914a4ae452c9f6ad5d462ce3d277798075b107615c1a8a30"
-&amp;gt; (define checksum (substring (sha256 (sha256 hash160/extended)) 0 8))
-&amp;gt; checksum
"d61967f6"
-&amp;gt; (define address/hex (string-append hash160/extended checksum))
-&amp;gt; address/hex
"00010966776006953d5567439e5e39f86a0d273beed61967f6"
   &lt;/code&gt;&lt;/pre&gt;
 &lt;p&gt;The last command computes the Bitcoin address in hexadecimal format. The Bitcoin wiki article performs one more step to convert to &lt;a href="https://en.bitcoin.it/wiki/Base58Check_encoding" title="Bitcoin wiki: Base58Check encoding"&gt;Base58Check encoding&lt;/a&gt;, which is the standard representation for Bitcoin addresses. We&amp;rsquo;ll look at Base58Check encoding in the next post!&lt;/p&gt;
 &lt;h3 id="software"&gt;Software&lt;/h3&gt;
 &lt;p&gt;The code from this post can be downloaded here. In this post, I&amp;rsquo;m using OpenSSL 1.0.1e with Racket 6.0.0.3 running in Debian 7.0.&lt;/p&gt;&lt;/html&gt;</content></entry>
 <entry>
  <title type="text">Deriving a Bitcoin Public Key From a Private Key</title>
  <link rel="alternate" href="http://www.lostintransaction.com/blog/2014/03/14/deriving-a-bitcoin-public-key-from-a-private-key/?utm_source=OpenSSL&amp;utm_medium=Atom" />
  <id>urn:http-www-lostintransaction-com:-blog-2014-03-14-deriving-a-bitcoin-public-key-from-a-private-key</id>
  <published>2014-03-14T05:28:01Z</published>
  <updated>2014-03-14T05:28:01Z</updated>
  <author>
   <name>The Unknown Author</name></author>
  <content type="html">
&lt;html&gt;&lt;img src="http://www.lostintransaction.com/img/1x1.gif?utm_source=OpenSSL&amp;amp;utm_medium=Atom&amp;amp;utm_campaign=%2Fblog%2F2014%2F03%2F14%2Fderiving-a-bitcoin-public-key-from-a-private-key%2F" height="1" width="1" /&gt;
 &lt;p&gt;I&amp;rsquo;ve been wondering about the relationship between Bitcoin public and private keys. I know they are &lt;a href="http://en.wikipedia.org/wiki/Elliptic_Curve_DSA" title="Wikipedia: Elliptic Curve DSA"&gt;Elliptic Curve DSA (ECDSA)&lt;/a&gt; key pairs, and I&amp;rsquo;ve seen the &lt;a href="http://stackoverflow.com/questions/12480776/how-do-i-obtain-the-public-key-from-an-ecdsa-private-key-in-openssl" title="Stack Overflow: Public Key from Private Key"&gt;&lt;code&gt;Q = dG&lt;/code&gt; explanation&lt;/a&gt; on a few sites, but they leave out some details. I wanted to experiment for myself, so this post describes how to derive a public key from a private key with runnable C code.&lt;/p&gt;
 &lt;p&gt;The &lt;a href="http://stackoverflow.com/a/12482384/951881" title="Stack Overflow: Public Key from Private Key Answer"&gt;accepted Stack Overflow answer from the previous link&lt;/a&gt; says that in the &lt;code&gt;Q = dG&lt;/code&gt; equation, &lt;code&gt;Q&lt;/code&gt; is the public key and &lt;code&gt;d&lt;/code&gt; is the private key, but does not explain &lt;code&gt;G&lt;/code&gt;, the group parameter. Luckily, some Googling quickly finds that Bitcoin uses the &lt;a href="https://en.bitcoin.it/wiki/Secp256k1" title="secp256k1 Bitcoin wiki entry"&gt;&lt;code&gt;secp256k1&lt;/code&gt; ECDSA curve&lt;/a&gt;.&lt;/p&gt;
 &lt;p&gt;Next, I looked at the &lt;a href="https://www.openssl.org/" title="OpenSSL"&gt;OpenSSL&lt;/a&gt; &lt;code&gt;libcrypto&lt;/code&gt; library, in the &lt;a href="http://git.openssl.org/gitweb/?p=openssl.git;a=blob;f=crypto/ec/ec_key.c;h=7fa247593d91b45347704e62e184e1138fc8bd01;hb=46ebd9e3bb623d3c15ef2203038956f3f7213620#l236" title="crypto/ec/ec_key.c"&gt;function mentioned in the Stack Overflow post, &lt;code&gt;EC_KEY_generate_key&lt;/code&gt;&lt;/a&gt;. Here&amp;rsquo;s the line that performs the multiplication:&lt;/p&gt;
 &lt;pre class="brush: c"&gt;&lt;code&gt;EC_POINT_mul(eckey-&amp;gt;group, pub_key, priv_key, NULL, NULL, ctx);&lt;/code&gt;&lt;/pre&gt;
 &lt;p&gt;In this case, I&amp;rsquo;m supplying &lt;code&gt;priv_key&lt;/code&gt;, and &lt;code&gt;pub_key&lt;/code&gt; is the output parameter, so I just need the appropriate group for the first parameter. OpenSSL has &lt;a href="http://git.openssl.org/gitweb/?p=openssl.git;a=blob;f=crypto/objects/obj_mac.h;h=b5ea7cdab4f84b90280f0a3aae1478a8d715c7a7;hb=46ebd9e3bb623d3c15ef2203038956f3f7213620#l385" title="crypto/objects/obj_mac.h"&gt;already defined the &lt;code&gt;secp256k1&lt;/code&gt; curve&lt;/a&gt;, so it&amp;rsquo;s just a matter of getting the right data representation. Here is the &lt;a href="http://git.openssl.org/gitweb/?p=openssl.git;a=blob;f=crypto/ec/ec.h;h=dfe8710d330954bb1762a5fe13d655ac7a5f01be;hb=46ebd9e3bb623d3c15ef2203038956f3f7213620#l643" title="crypto/ec/ec.h"&gt;header for &lt;code&gt;EC_POINT_mul&lt;/code&gt;&lt;/a&gt; from the OpenSSL library:&lt;/p&gt;
 &lt;pre class="brush: c"&gt;&lt;code&gt;/** Computes r = generator * n + q * m
 *  \param  group  underlying EC_GROUP object
 *  \param  r      EC_POINT object for the result
 *  \param  n      BIGNUM with the multiplier for the group generator (optional)
 *  \param  q      EC_POINT object with the first factor of the second summand
 *  \param  m      BIGNUM with the second factor of the second summand
 *  \param  ctx    BN_CTX object (optional)
 *  \return 1 on success and 0 if an error occured
 */
int EC_POINT_mul(const EC_GROUP *group, EC_POINT *r, const BIGNUM *n, const EC_POINT *q, const BIGNUM *m, BN_CTX *ctx);&lt;/code&gt;&lt;/pre&gt;
 &lt;p&gt;Looks like we need an &lt;code&gt;EC_GROUP&lt;/code&gt; and to create one we can use &lt;a href="http://git.openssl.org/gitweb/?p=openssl.git;a=blob;f=crypto/ec/ec_curve.c;h=c72fb2697ca2823a4aac36b027012bed6c457288;hb=46ebd9e3bb623d3c15ef2203038956f3f7213620#l2057" title="crypco/ec/ec_curve.c"&gt;&lt;code&gt;EC_GROUP_new_by_curve_name&lt;/code&gt;&lt;/a&gt;.&lt;/p&gt;
 &lt;p&gt;Putting everything together, here&amp;rsquo;s what I came up with to compute a public key from a private key (disclaimer: the code has no error-checking and is obviously not production-quality):&lt;/p&gt;
 &lt;pre class="brush: c"&gt;&lt;code&gt;#include &amp;lt;stdlib.h&amp;gt;
#include &amp;lt;stdio.h&amp;gt;
#include &amp;lt;openssl/ec.h&amp;gt;
#include &amp;lt;openssl/obj_mac.h&amp;gt; // for NID_secp256k1

#define PRIV_KEY_LEN 32
#define PUB_KEY_LEN 65

// calculates and returns the public key associated with the given private key
// - input private key and output public key are in hexadecimal
unsigned char *priv2pub( const unsigned char *priv_hex )
{
  EC_GROUP *ecgrp = EC_GROUP_new_by_curve_name( NID_secp256k1 );
  
  // convert priv key from BIGNUM to hexadecimal
  BIGNUM *priv_bn = BN_new();
  BN_hex2bn( &amp;amp;priv_bn, priv_hex );
  
  // compute pub key from priv key and group
  EC_POINT *pub = EC_POINT_new( ecgrp );
  EC_POINT_mul( ecgrp, pub, priv_bn, NULL, NULL, NULL );
                              
  // convert pub_key from EC_POINT curve coordinate to hexadecimal
  unsigned char *ret = EC_POINT_point2hex( ecgrp, pub, POINT_CONVERSION_UNCOMPRESSED, NULL );
    
  EC_GROUP_free( ecgrp ); BN_free( priv_bn ); EC_POINT_free( pub );
  
  return ret;
}

int main( int argc, const unsigned char *argv[] )
{
  // compute pub key
  unsigned char *pub_hex = priv2pub( argv[1] );
  
  // print computed pub key
  for( size_t i = 0; i &amp;lt; PUB_KEY_LEN * 2; i++ ) {
    printf( "%c", pub_hex[i] );
  }
  printf( "\n" );
  
  free( pub_hex );
  
  return 0;
}&lt;/code&gt;&lt;/pre&gt;
 &lt;p&gt;Bitcoin private keys are 32 bytes and public keys are 65 bytes. The &lt;code&gt;priv2pub&lt;/code&gt; function computes the public key associated with the given private key. Both the input private key and the output public key are in hexadecimal. I had to first convert the private key to &lt;code&gt;BIGNUM&lt;/code&gt;, which is OpenSSL&amp;rsquo;s number representation for arbitrary precision arithmetic. The computed public key is a curve coordinate in OpenSSL&amp;rsquo;s &lt;code&gt;EC_POINT&lt;/code&gt; representation. I then convert back to hex using &lt;code&gt;EC_POINT_point2hex&lt;/code&gt;.&lt;/p&gt;
 &lt;p&gt;To test, I found a sample public/private key pair from &lt;a href="https://en.bitcoin.it/wiki/Technical_background_of_version_1_Bitcoin_addresses" title="Bitcoin wiki: technical explanation of addresses"&gt;this Bitcoin wiki article&lt;/a&gt;. The private key from the article is &lt;code&gt;18E14A7B6A307F426A94F8114701E7C8E774E7F9A47E2C2035DB29A206321725&lt;/code&gt; and the public key is &lt;code&gt;0450863AD64A87AE8A2FE83C1AF1A8403CB53F53E486D8511DAD8A04887E5B23522CD470243453A299FA9E77237716103ABC11A1DF38855ED6F2EE187E9C582BA6&lt;/code&gt;. Let&amp;rsquo;s see if our program can recover this public key from the private key. (I save the code above to a file &lt;code&gt;blog.c&lt;/code&gt;.)&lt;/p&gt;
 &lt;pre&gt;&lt;code&gt;$ gcc -lcrypto -std=c99 blog.c
$ ./a.out 18E14A7B6A307F426A94F8114701E7C8E774E7F9A47E2C2035DB29A206321725
0450863AD64A87AE8A2FE83C1AF1A8403CB53F53E486D8511DAD8A04887E5B23522CD470243453A299FA9E77237716103ABC11A1DF38855ED6F2EE187E9C582BA6&lt;/code&gt;&lt;/pre&gt;
 &lt;p&gt;Success!&lt;/p&gt;
 &lt;p&gt;Let&amp;rsquo;s do another one. I generated a private key with &lt;a href="https://www.bitaddress.org"&gt;bitaddress.org&lt;/a&gt;, &lt;code&gt;5JQZaZrYCbJ1Kb96vFBMEefrQGuNfHSqbHbviC3URUNGJ27frFe&lt;/code&gt;, but it&amp;rsquo;s in &lt;a href="https://en.bitcoin.it/wiki/Base58Check_encoding" title="Bitcoin wiki: Base58Check encoding"&gt;Base58Check encoding&lt;/a&gt; and not hex. So I went to the &amp;ldquo;Wallet Details&amp;rdquo; tab, entered the base58 key, and &lt;a href="https://www.bitaddress.org"&gt;bitaddress.org&lt;/a&gt; reports that the private key in hex is &lt;code&gt;4DD3D47E491C5D34F9540EBF3444E3D6675015A46B61AF37B4EB7F17DDDF4E61&lt;/code&gt; and public key is &lt;code&gt;0492EDC09A7311C2AB83EF3D133331D7B73117902BB391D9DAC3BE261547F571E171F16775DDA6D09A6AAF1F3F6E6AA3CFCD854DCAA6AED0FA7AF9A5ED9965E117&lt;/code&gt;. Let&amp;rsquo;s check with our code:&lt;/p&gt;
 &lt;pre&gt;&lt;code&gt;$ ./a.out 4DD3D47E491C5D34F9540EBF3444E3D6675015A46B61AF37B4EB7F17DDDF4E61
0492EDC09A7311C2AB83EF3D133331D7B73117902BB391D9DAC3BE261547F571E171F16775DDA6D09A6AAF1F3F6E6AA3CFCD854DCAA6AED0FA7AF9A5ED9965E117&lt;/code&gt;&lt;/pre&gt;
 &lt;p&gt;Hurrah!&lt;/p&gt;
 &lt;h3 id="software"&gt;Software&lt;/h3&gt;
 &lt;p&gt;In this post, I&amp;rsquo;m using OpenSSL 1.0.1e, gcc 4.7.2, and running Debian 7.0. I had to also install the &lt;code&gt;libssl-dev&lt;/code&gt; package to get the proper header files.&lt;/p&gt;&lt;/html&gt;</content></entry></feed>