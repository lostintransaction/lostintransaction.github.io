<?xml version="1.0" encoding="utf-8"?> 
<rss version="2.0">
 <channel>
  <title>Lost in Transaction: A neophyte explores Bitcoin: All Posts</title>
  <description>Lost in Transaction: A neophyte explores Bitcoin: All Posts</description>
  <link>http://www.lostintransaction.com/index.html</link>
  <lastBuildDate>Sat, 15 Mar 2014 04:09:45 UTC</lastBuildDate>
  <pubDate>Sat, 15 Mar 2014 04:09:45 UTC</pubDate>
  <ttl>1800</ttl>
  <item>
   <title>Adding OpenSSL bindings to Racket via its FFI</title>
   <link>http://www.lostintransaction.com/blog/2014/03/15/adding-openssl-bindings-to-racket-via-its-ffi/?utm_source=all&amp;utm_medium=RSS</link>
   <guid>urn:http-www-lostintransaction-com:-blog-2014-03-15-adding-openssl-bindings-to-racket-via-its-ffi</guid>
   <pubDate>Sat, 15 Mar 2014 04:09:45 UTC</pubDate>
   <description>
&lt;html&gt;&lt;img src="http://www.lostintransaction.com/img/1x1.gif?utm_source=all&amp;amp;utm_medium=RSS&amp;amp;utm_campaign=%2Fblog%2F2014%2F03%2F15%2Fadding-openssl-bindings-to-racket-via-its-ffi%2F" height="1" width="1" /&gt;
 &lt;p&gt;C programming has its uses but it&amp;rsquo;s also sometimes nice to program with a higher-level language where you don&amp;rsquo;t need to constantly worry about things like overflow or freeing memory. I enjoy using &lt;a href="http://racket-lang.org"&gt;Racket&lt;/a&gt;, a LISP dialect, when experimenting with Bitcoin.&lt;/p&gt;
 &lt;p&gt;Unfortunately, Racket doesn&amp;rsquo;t have a complete crypto librar.It does have, however, an &lt;a href="http://docs.racket-lang.org/foreign/index.html" title="Racket FFI"&gt;FFI&lt;/a&gt; that enables Racket code to directly call C functions. In this post, I create Racket bindings for two important hashing functions used by Bitcoin, &lt;a href="http://en.wikipedia.org/wiki/SHA-2" title="Wikipedia: SHA-2"&gt;SHA&amp;ndash;256&lt;/a&gt; and &lt;a href="http://en.wikipedia.org/wiki/RIPEMD" title="Wikipedia: RIPEMD"&gt;RIPEMD&amp;ndash;160&lt;/a&gt;.&lt;/p&gt;
 &lt;h3 id="ffi-lib"&gt;&lt;code&gt;ffi-lib&lt;/code&gt;&lt;/h3&gt;
 &lt;p&gt;The &lt;a href="http://docs.racket-lang.org/foreign/Loading_Foreign_Libraries.html?q=ffi-lib#%28def._%28%28lib._ffi%2Funsafe..rkt%29._ffi-lib%29%29" title="Racket docs: ffi-lib"&gt;&lt;code&gt;ffi-lib&lt;/code&gt;&lt;/a&gt; Racket function in the &lt;code&gt;ffi/unsafe&lt;/code&gt; module creates a Racket value that represents the given C library. Racket actually already defines &lt;a href="https://github.com/plt/racket/blob/8b4c5d3debbe41c90e37e5ffdc55fb8ab3635f92/racket/collects/openssl/libcrypto.rkt" title="Racket source: openssl/libcrypto.rkt"&gt;a &lt;code&gt;libcrypto&lt;/code&gt; identifier&lt;/a&gt;, which represents the OpenSSL &lt;code&gt;libcrypto&lt;/code&gt; library (Racket has wrapper functions for some &lt;code&gt;libcrypto&lt;/code&gt; C functions, but not for &lt;code&gt;SHA256&lt;/code&gt; or &lt;code&gt;RIPEMD160&lt;/code&gt;). Here&amp;rsquo;s how to define a Racket value representing the &lt;code&gt;libcrypto&lt;/code&gt; library using &lt;code&gt;ffi-lib&lt;/code&gt;:&lt;/p&gt;
 &lt;pre class="brush: racket"&gt;&lt;code&gt;(define libcrypto
  (ffi-lib '(so "libcrypto") '("" "1.0.1e" "1.0.0" "1.0" "0.9.8b" "0.9.8" "0.9.7")))&lt;/code&gt;&lt;/pre&gt;
 &lt;p&gt;The first argument specifies a dynamic C library and the second argument is a list of acceptable versions. See the documentation for &lt;a href="http://docs.racket-lang.org/foreign/Loading_Foreign_Libraries.html?q=ffi-lib#%28def._%28%28lib._ffi%2Funsafe..rkt%29._ffi-lib%29%29" title="Racket docs: ffi-lib"&gt;&lt;code&gt;ffi-lib&lt;/code&gt;&lt;/a&gt; for more details on its usage.&lt;/p&gt;
 &lt;h3 id="get-ffi-obj"&gt;&lt;code&gt;get-ffi-obj&lt;/code&gt;&lt;/h3&gt;
 &lt;p&gt;Let&amp;rsquo;s create a Racket wrapper function for the &lt;a href="http://git.openssl.org/gitweb/?p=openssl.git;a=blob;f=crypto/sha/sha.h;h=8a6bf4bbbb1dbef37869fc162ce1c2cacfebeb1d;hb=46ebd9e3bb623d3c15ef2203038956f3f7213620#l155" title="OpenSSL source: crypto/sha/sha.h"&gt;&lt;code&gt;SHA256&lt;/code&gt;&lt;/a&gt; C function. Here&amp;rsquo;s the header:&lt;/p&gt;
 &lt;pre class="brush: C"&gt;&lt;code&gt;unsigned char *SHA256( const unsigned char *d, size_t n, unsigned char *md );&lt;/code&gt;&lt;/pre&gt;
 &lt;p&gt;To create a Racket wrapper function, we use &lt;a href="http://docs.racket-lang.org/foreign/Loading_Foreign_Libraries.html?q=get-ffi-obj#%28def._%28%28lib._ffi%2Funsafe..rkt%29._get-ffi-obj%29%29" title="Racket docs: get-ffi-obj"&gt;&lt;code&gt;get-ffi-obj&lt;/code&gt;&lt;/a&gt;. Here&amp;rsquo;s one possible way to define a Racket &lt;code&gt;sha256&lt;/code&gt; function that calls the C &lt;code&gt;SHA256&lt;/code&gt; function:&lt;/p&gt;
 &lt;pre class="brush: racket"&gt;&lt;code&gt;(define sha256
  (get-ffi-obj
    'SHA256 libcrypto
    (_fun [input     : _bytes]
          [input-len : _ulong = (bytes-length input)]
          [output    : (_bytes o SHA256-DIGEST-LEN)]
        -&amp;gt; (_bytes o SHA256-DIGEST-LEN))))&lt;/code&gt;&lt;/pre&gt;
 &lt;p&gt;The first argument to &lt;code&gt;get-ffi-obj&lt;/code&gt; is the name of the C function and the second is the library hook that we created with &lt;code&gt;ffi-lib&lt;/code&gt; earlier. The third argument is the type, which specifies how to mediate between Racket and C values. &lt;a href="http://docs.racket-lang.org/foreign/foreign_procedures.html?q=_fun#%28form._%28%28lib._ffi%2Funsafe..rkt%29.__fun%29%29" title="Racket docs: _fun"&gt;&lt;code&gt;_fun&lt;/code&gt;&lt;/a&gt; specifies a function type and in this case the function has three arguments (each in brackets).&lt;/p&gt;
 &lt;p&gt;Examining the arguments:&lt;/p&gt;
 &lt;ol&gt;
  &lt;li&gt;
   &lt;p&gt;The first argument to the C &lt;code&gt;SHA256&lt;/code&gt; function is an array of input bytes. Accordingly, &lt;code&gt;get-ffi-obj&lt;/code&gt; specifies this with a &lt;code&gt;_bytes&lt;/code&gt; type.&lt;/p&gt;&lt;/li&gt;
  &lt;li&gt;
   &lt;p&gt;The second argument is the length of the input byte array. The &lt;code&gt;=&lt;/code&gt; tells Racket how to calculate this argument automatically. This means that a caller of the Racket &lt;code&gt;sha256&lt;/code&gt; function only needs to provide the input bytes and not an additional length argument.&lt;/p&gt;&lt;/li&gt;
  &lt;li&gt;
   &lt;p&gt;The third argument is the output byte array. The &lt;code&gt;o&lt;/code&gt; indicates a return pointer and &lt;code&gt;SHA256-DIGEST-LEN&lt;/code&gt; is the expected number of output bytes.&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;
 &lt;p&gt;Here&amp;rsquo;s the entire code to define a Racket module that exports &lt;code&gt;sha256&lt;/code&gt; and &lt;code&gt;ripemd160&lt;/code&gt; wrapper functions. Note that the functions that call to the C functions are now named &lt;code&gt;sha256/bytes&lt;/code&gt; and &lt;code&gt;ripemd160/bytes&lt;/code&gt;, and these functions consume and produce bytes. We additionally define &lt;code&gt;sha256&lt;/code&gt; and &lt;code&gt;ripemd160&lt;/code&gt; functions which have optional keyword arguments for conversion of the input and output. &lt;code&gt;sha256&lt;/code&gt; and &lt;code&gt;ripemd160&lt;/code&gt; consume hexadecimal strings by default.&lt;/p&gt;
 &lt;h3 id="testing"&gt;Testing&lt;/h3&gt;
 &lt;p&gt;To test our wrapper functions, let&amp;rsquo;s see if we can duplicate &lt;a href="https://en.bitcoin.it/wiki/Technical_background_of_version_1_Bitcoin_addresses" title="Bitcoin Wiki: Technical background of version 1 Bitcoin addresses"&gt;this example&lt;/a&gt;, which converts a Bitcoin private key into an address. We covered &lt;a href="http://www.lostintransaction.com/blog/2014/03/14/deriving-a-bitcoin-public-key-from-a-private-key/" title="Deriving a Bitcoin Public Key From a Private Key"&gt;how to calculate a public key from a private key&lt;/a&gt; in a previous post, so we start with the public key here.&lt;/p&gt;
 &lt;p&gt;For ease of comparison, here&amp;rsquo;s the sequence of expected hashes, copied from the Bitcoin wiki example:&lt;/p&gt;
 &lt;ol&gt;
  &lt;li&gt;public key: &lt;code&gt;0450863AD64A87AE8A2FE83C1AF1A8403CB53F53E486D8511DAD8A04887E5B23522CD470243453A299FA9E77237716103ABC11A1DF38855ED6F2EE187E9C582BA6&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;SHA&amp;ndash;256: &lt;code&gt;600FFE422B4E00731A59557A5CCA46CC183944191006324A447BDB2D98D4B408&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;RIPEMD&amp;ndash;160: &lt;code&gt;010966776006953D5567439E5E39F86A0D273BEE&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;prepend &lt;code&gt;0x00&lt;/code&gt;: &lt;code&gt;00010966776006953D5567439E5E39F86A0D273BEE&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;SHA&amp;ndash;256: &lt;code&gt;445C7A8007A93D8733188288BB320A8FE2DEBD2AE1B47F0F50BC10BAE845C094&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;SHA&amp;ndash;256 (checksum is first 4 bytes): &lt;code&gt;D61967F63C7DD183914A4AE452C9F6AD5D462CE3D277798075B107615C1A8A30&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;checksum + #4 = (hex) address: &lt;code&gt;00010966776006953D5567439E5E39F86A0D273BEED61967F6&lt;/code&gt;&lt;/li&gt;&lt;/ol&gt;
 &lt;p&gt;And here&amp;rsquo;s what the computations look like with our new library (using the Racket REPL):&lt;/p&gt;
 &lt;pre&gt;&lt;code&gt;$ racket
Welcome to Racket v6.0.0.3.
-&amp;gt; (require "crypto.rkt")
-&amp;gt; (define pub-key "0450863AD64A87AE8A2FE83C1AF1A8403CB53F53E486D8511DAD8A04887E5B23522CD470243453A299FA9E77237716103ABC11A1DF38855ED6F2EE187E9C582BA6")
-&amp;gt; (sha256 pub-key)
"600ffe422b4e00731a59557a5cca46cc183944191006324a447bdb2d98d4b408"
-&amp;gt; (ripemd160 (sha256 pub-key))
"010966776006953d5567439e5e39f86a0d273bee"
-&amp;gt; (define hash160 (ripemd160 (sha256 pub-key)))
-&amp;gt; (define hash160/extended (string-append "00" hash160))
-&amp;gt; (sha256 hash160/extended)
"445c7a8007a93d8733188288bb320a8fe2debd2ae1b47f0f50bc10bae845c094"
-&amp;gt; (sha256 (sha256 hash160/extended))
"d61967f63c7dd183914a4ae452c9f6ad5d462ce3d277798075b107615c1a8a30"
-&amp;gt; (define checksum (substring (sha256 (sha256 hash160/extended)) 0 8))
-&amp;gt; checksum
"d61967f6"
-&amp;gt; (define address/hex (string-append hash160/extended checksum))
-&amp;gt; address/hex
"00010966776006953d5567439e5e39f86a0d273beed61967f6"
   &lt;/code&gt;&lt;/pre&gt;
 &lt;p&gt;In the next post, I&amp;rsquo;ll experiment with [Base58Check encoding][bwiki:b58] and decoding.&lt;/p&gt;
 &lt;h3 id="software"&gt;Software&lt;/h3&gt;
 &lt;p&gt;In this post, I&amp;rsquo;m using OpenSSL 1.0.1e, Racket 6.0.0.3, and running Debian 7.0.&lt;/p&gt;&lt;/html&gt;</description></item>
  <item>
   <title>Deriving a Bitcoin Public Key From a Private Key</title>
   <link>http://www.lostintransaction.com/blog/2014/03/14/deriving-a-bitcoin-public-key-from-a-private-key/?utm_source=all&amp;utm_medium=RSS</link>
   <guid>urn:http-www-lostintransaction-com:-blog-2014-03-14-deriving-a-bitcoin-public-key-from-a-private-key</guid>
   <pubDate>Fri, 14 Mar 2014 05:28:01 UTC</pubDate>
   <description>
&lt;html&gt;&lt;img src="http://www.lostintransaction.com/img/1x1.gif?utm_source=all&amp;amp;utm_medium=RSS&amp;amp;utm_campaign=%2Fblog%2F2014%2F03%2F14%2Fderiving-a-bitcoin-public-key-from-a-private-key%2F" height="1" width="1" /&gt;
 &lt;p&gt;I&amp;rsquo;ve been wondering about the relationship between Bitcoin public and private keys. I know they are &lt;a href="http://en.wikipedia.org/wiki/Elliptic_Curve_DSA" title="Wikipedia: Elliptic Curve DSA"&gt;Elliptic Curve DSA (ECDSA)&lt;/a&gt; key pairs, and I&amp;rsquo;ve seen the &lt;a href="http://stackoverflow.com/questions/12480776/how-do-i-obtain-the-public-key-from-an-ecdsa-private-key-in-openssl" title="Stack Overflow: Public Key from Private Key"&gt;&lt;code&gt;Q = dG&lt;/code&gt; explanation&lt;/a&gt; on a few sites, but they leave out some details. I wanted to experiment for myself, so this post describes how to derive a public key from a private key with runnable C code.&lt;/p&gt;
 &lt;p&gt;The &lt;a href="http://stackoverflow.com/a/12482384/951881" title="Stack Overflow: Public Key from Private Key Answer"&gt;accepted Stack Overflow answer from the previous link&lt;/a&gt; says that in the &lt;code&gt;Q = dG&lt;/code&gt; equation, &lt;code&gt;Q&lt;/code&gt; is the public key and &lt;code&gt;d&lt;/code&gt; is the private key, but does not explain &lt;code&gt;G&lt;/code&gt;, the group parameter. Luckily, some Googling quickly finds that Bitcoin uses the &lt;a href="https://en.bitcoin.it/wiki/Secp256k1" title="secp256k1 Bitcoin wiki entry"&gt;&lt;code&gt;secp256k1&lt;/code&gt; ECDSA curve&lt;/a&gt;.&lt;/p&gt;
 &lt;p&gt;Next, I looked at the &lt;a href="https://www.openssl.org/" title="OpenSSL"&gt;OpenSSL&lt;/a&gt; &lt;code&gt;libcrypto&lt;/code&gt; library, in the &lt;a href="http://git.openssl.org/gitweb/?p=openssl.git;a=blob;f=crypto/ec/ec_key.c;h=7fa247593d91b45347704e62e184e1138fc8bd01;hb=46ebd9e3bb623d3c15ef2203038956f3f7213620#l236" title="crypto/ec/ec_key.c"&gt;function mentioned in the Stack Overflow post, &lt;code&gt;EC_KEY_generate_key&lt;/code&gt;&lt;/a&gt;. Here&amp;rsquo;s the line that performs the multiplication:&lt;/p&gt;
 &lt;pre class="brush: c"&gt;&lt;code&gt;EC_POINT_mul(eckey-&amp;gt;group, pub_key, priv_key, NULL, NULL, ctx);&lt;/code&gt;&lt;/pre&gt;
 &lt;p&gt;In this case, I&amp;rsquo;m supplying &lt;code&gt;priv_key&lt;/code&gt;, and &lt;code&gt;pub_key&lt;/code&gt; is the output parameter, so I just need the appropriate group for the first parameter. OpenSSL has &lt;a href="http://git.openssl.org/gitweb/?p=openssl.git;a=blob;f=crypto/objects/obj_mac.h;h=b5ea7cdab4f84b90280f0a3aae1478a8d715c7a7;hb=46ebd9e3bb623d3c15ef2203038956f3f7213620#l385" title="crypto/objects/obj_mac.h"&gt;already defined the &lt;code&gt;secp256k1&lt;/code&gt; curve&lt;/a&gt;, so it&amp;rsquo;s just a matter of getting the right data representation. Here is the &lt;a href="http://git.openssl.org/gitweb/?p=openssl.git;a=blob;f=crypto/ec/ec.h;h=dfe8710d330954bb1762a5fe13d655ac7a5f01be;hb=46ebd9e3bb623d3c15ef2203038956f3f7213620#l643" title="crypto/ec/ec.h"&gt;header for &lt;code&gt;EC_POINT_mul&lt;/code&gt;&lt;/a&gt; from the OpenSSL library:&lt;/p&gt;
 &lt;pre class="brush: c"&gt;&lt;code&gt;/** Computes r = generator * n + q * m
 *  \param  group  underlying EC_GROUP object
 *  \param  r      EC_POINT object for the result
 *  \param  n      BIGNUM with the multiplier for the group generator (optional)
 *  \param  q      EC_POINT object with the first factor of the second summand
 *  \param  m      BIGNUM with the second factor of the second summand
 *  \param  ctx    BN_CTX object (optional)
 *  \return 1 on success and 0 if an error occured
 */
int EC_POINT_mul(const EC_GROUP *group, EC_POINT *r, const BIGNUM *n, const EC_POINT *q, const BIGNUM *m, BN_CTX *ctx);&lt;/code&gt;&lt;/pre&gt;
 &lt;p&gt;Looks like we need an &lt;code&gt;EC_GROUP&lt;/code&gt; and to create one we can use &lt;a href="http://git.openssl.org/gitweb/?p=openssl.git;a=blob;f=crypto/ec/ec_curve.c;h=c72fb2697ca2823a4aac36b027012bed6c457288;hb=46ebd9e3bb623d3c15ef2203038956f3f7213620#l2057" title="crypco/ec/ec_curve.c"&gt;&lt;code&gt;EC_GROUP_new_by_curve_name&lt;/code&gt;&lt;/a&gt;.&lt;/p&gt;
 &lt;p&gt;Putting everything together, here&amp;rsquo;s what I came up with to compute a public key from a private key (disclaimer: the code has no error-checking and is obviously not production-quality):&lt;/p&gt;
 &lt;pre class="brush: c"&gt;&lt;code&gt;#include &amp;lt;stdlib.h&amp;gt;
#include &amp;lt;stdio.h&amp;gt;
#include &amp;lt;openssl/ec.h&amp;gt;
#include &amp;lt;openssl/obj_mac.h&amp;gt; // for NID_secp256k1

#define PRIV_KEY_LEN 32
#define PUB_KEY_LEN 65

// calculates and returns the public key associated with the given private key
// - input private key and output public key are in hexadecimal
unsigned char *priv2pub( const unsigned char *priv_hex )
{
  EC_GROUP *ecgrp = EC_GROUP_new_by_curve_name( NID_secp256k1 );
  
  // convert priv key from BIGNUM to hexadecimal
  BIGNUM *priv_bn = BN_new();
  BN_hex2bn( &amp;amp;priv_bn, priv_hex );
  
  // compute pub key from priv key and group
  EC_POINT *pub = EC_POINT_new( ecgrp );
  EC_POINT_mul( ecgrp, pub, priv_bn, NULL, NULL, NULL );
                              
  // convert pub_key from EC_POINT curve coordinate to hexadecimal
  unsigned char *ret = EC_POINT_point2hex( ecgrp, pub, POINT_CONVERSION_UNCOMPRESSED, NULL );
    
  EC_GROUP_free( ecgrp ); BN_free( priv_bn ); EC_POINT_free( pub );
  
  return ret;
}

int main( int argc, const unsigned char *argv[] )
{
  // compute pub key
  unsigned char *pub_hex = priv2pub( argv[1] );
  
  // print computed pub key
  for( size_t i = 0; i &amp;lt; PUB_KEY_LEN * 2; i++ ) {
    printf( "%c", pub_hex[i] );
  }
  printf( "\n" );
  
  free( pub_hex );
  
  return 0;
}&lt;/code&gt;&lt;/pre&gt;
 &lt;p&gt;Bitcoin private keys are 32 bytes and public keys are 65 bytes. The &lt;code&gt;priv2pub&lt;/code&gt; function computes the public key associated with the given private key. Both the input private key and the output public key are in hexadecimal. I had to first convert the private key to &lt;code&gt;BIGNUM&lt;/code&gt;, which is OpenSSL&amp;rsquo;s number representation for arbitrary precision arithmetic. The computed public key is a curve coordinate in OpenSSL&amp;rsquo;s &lt;code&gt;EC_POINT&lt;/code&gt; representation. I then convert back to hex using &lt;code&gt;EC_POINT_point2hex&lt;/code&gt;.&lt;/p&gt;
 &lt;p&gt;To test, I found a sample public/private key pair from &lt;a href="https://en.bitcoin.it/wiki/Technical_background_of_version_1_Bitcoin_addresses" title="Bitcoin wiki: technical explanation of addresses"&gt;this Bitcoin wiki article&lt;/a&gt;. The private key from the article is &lt;code&gt;18E14A7B6A307F426A94F8114701E7C8E774E7F9A47E2C2035DB29A206321725&lt;/code&gt; and the public key is &lt;code&gt;0450863AD64A87AE8A2FE83C1AF1A8403CB53F53E486D8511DAD8A04887E5B23522CD470243453A299FA9E77237716103ABC11A1DF38855ED6F2EE187E9C582BA6&lt;/code&gt;. Let&amp;rsquo;s see if our program can recover this public key from the private key. (I save the code above to a file &lt;code&gt;blog.c&lt;/code&gt;.)&lt;/p&gt;
 &lt;pre&gt;&lt;code&gt;$ gcc -lcrypto -std=c99 blog.c
$ ./a.out 18E14A7B6A307F426A94F8114701E7C8E774E7F9A47E2C2035DB29A206321725
0450863AD64A87AE8A2FE83C1AF1A8403CB53F53E486D8511DAD8A04887E5B23522CD470243453A299FA9E77237716103ABC11A1DF38855ED6F2EE187E9C582BA6&lt;/code&gt;&lt;/pre&gt;
 &lt;p&gt;Success!&lt;/p&gt;
 &lt;p&gt;Let&amp;rsquo;s do another one. I generated a private key with &lt;a href="https://www.bitaddress.org"&gt;bitaddress.org&lt;/a&gt;, &lt;code&gt;5JQZaZrYCbJ1Kb96vFBMEefrQGuNfHSqbHbviC3URUNGJ27frFe&lt;/code&gt;, but it&amp;rsquo;s in &lt;a href="https://en.bitcoin.it/wiki/Base58Check_encoding" title="Bitcoin wiki: Base58Check encoding"&gt;Base58Check encoding&lt;/a&gt; and not hex. So I went to the &amp;ldquo;Wallet Details&amp;rdquo; tab, entered the base58 key, and &lt;a href="https://www.bitaddress.org"&gt;bitaddress.org&lt;/a&gt; reports that the private key in hex is &lt;code&gt;4DD3D47E491C5D34F9540EBF3444E3D6675015A46B61AF37B4EB7F17DDDF4E61&lt;/code&gt; and public key is &lt;code&gt;0492EDC09A7311C2AB83EF3D133331D7B73117902BB391D9DAC3BE261547F571E171F16775DDA6D09A6AAF1F3F6E6AA3CFCD854DCAA6AED0FA7AF9A5ED9965E117&lt;/code&gt;. Let&amp;rsquo;s check with our code:&lt;/p&gt;
 &lt;pre&gt;&lt;code&gt;$ ./a.out 4DD3D47E491C5D34F9540EBF3444E3D6675015A46B61AF37B4EB7F17DDDF4E61
0492EDC09A7311C2AB83EF3D133331D7B73117902BB391D9DAC3BE261547F571E171F16775DDA6D09A6AAF1F3F6E6AA3CFCD854DCAA6AED0FA7AF9A5ED9965E117&lt;/code&gt;&lt;/pre&gt;
 &lt;p&gt;Hurrah!&lt;/p&gt;
 &lt;h3 id="software"&gt;Software&lt;/h3&gt;
 &lt;p&gt;In this post, I&amp;rsquo;m using OpenSSL 1.0.1e, gcc 4.7.2, and running Debian 7.0. I had to also install the &lt;code&gt;libssl-dev&lt;/code&gt; package to get the proper header files.&lt;/p&gt;&lt;/html&gt;</description></item>
  <item>
   <title>Verifying Andreas's "Fundraising for Dorian" Message</title>
   <link>http://www.lostintransaction.com/blog/2014/03/07/verifying-andreas-s-fundraising-for-dorian-message/?utm_source=all&amp;utm_medium=RSS</link>
   <guid>urn:http-www-lostintransaction-com:-blog-2014-03-07-verifying-andreas-s-fundraising-for-dorian-message</guid>
   <pubDate>Fri, 07 Mar 2014 18:52:52 UTC</pubDate>
   <description>
&lt;html&gt;&lt;img src="http://www.lostintransaction.com/img/1x1.gif?utm_source=all&amp;amp;utm_medium=RSS&amp;amp;utm_campaign=%2Fblog%2F2014%2F03%2F07%2Fverifying-andreas-s-fundraising-for-dorian-message%2F" height="1" width="1" /&gt;
 &lt;p&gt;Today, Andreas M. Antonopoulos, Chief Security Officer of Blockchain.info, started a &lt;a href="http://www.reddit.com/r/Bitcoin/comments/1ztjmg/andreas_im_fundraising_for_dorian_nakamoto/" title="Dorian fundraiser message on Reddit"&gt;fundraiser&lt;/a&gt; for Dorian Nakamoto, the guy who&amp;rsquo;s being harassed by the media due to Newsweek&amp;rsquo;s recent article about Satoshi Nakamoto. To prove that the message is not fake, Andreas &lt;a href="http://pastebin.com/4MHvpaeN" title="Dorian fundraiser message on Pastebin"&gt;signed the message&lt;/a&gt; with his public key. Since I&amp;rsquo;ve &lt;a href="http://www.lostintransaction.com/blog/2014/03/05/verifying-hashes-and-signatures/" title="Post: Verifying Hashes and Signatures"&gt;recently been playing with digital signatures&lt;/a&gt;, this seemed like a great chance to explore some more. Let&amp;rsquo;s try to to verify the message.&lt;/p&gt;
 &lt;p&gt;Unlike, &lt;a href="http://www.lostintransaction.com/blog/2014/03/05/verifying-hashes-and-signatures/" title="Post: Verifying Hashes and Signatures"&gt;when we wanted to verify the Multibit signature&lt;/a&gt;, Andreas posted a &lt;a href="http://gnupg.org/gph/en/manual/x135.html" title="GnuPG docs"&gt;clearsigned&lt;/a&gt; message, where the content and signature are in the same document. However, we can still use &lt;a href="http://www.gnupg.org/" title="GnuPG"&gt;GnuPG&lt;/a&gt; to verify the message.&lt;/p&gt;
 &lt;p&gt;First, we need Andreas&amp;rsquo;s public key. I went to the &lt;a href="http://pgp.mit.edu/"&gt;MIT PGP Public Key Server&lt;/a&gt; and &lt;a href="http://pgp.mit.edu/pks/lookup?search=%22Andreas+M.+Antonopoulos%22&amp;amp;op=index" title="Andreas PGP key search results"&gt;searched for &lt;code&gt;"Andreas M. Antonopoulos"&lt;/code&gt;&lt;/a&gt;. There were several results, so I arbitrarily chose the one associated with his domain name:&lt;/p&gt;
 &lt;pre&gt;&lt;code&gt;pub  4096R/2878DE4F 2013-12-14 Andreas M. Antonopoulos &amp;lt;andreas@antonopoulos.com&amp;gt;&lt;/code&gt;&lt;/pre&gt;
 &lt;p&gt;I then added the key to my database:&lt;/p&gt;
 &lt;pre&gt;&lt;code&gt;$ gpg2.exe" --keyserver pgp.mit.edu --recv-keys 0x2878DE4F
gpg: requesting key 2878DE4F from hkp server pgp.mit.edu
gpg: key 2878DE4F: public key "Andreas M. Antonopoulos &amp;lt;andreas@antonopoulos.com&amp;gt;" imported
gpg: Total number processed: 1
gpg:               imported: 1  (RSA: 1)&lt;/code&gt;&lt;/pre&gt;
 &lt;p&gt;Next, I downloaded the &lt;a href="http://pastebin.com/download.php?i=4MHvpaeN" title="download message txt file"&gt;message from Pastebin&lt;/a&gt; and tried to verify it:&lt;/p&gt;
 &lt;pre&gt;&lt;code&gt;$gpg2.exe" --verify andreas_fundraising_for_dorian.txt
gpg: Signature made 03/07/14 12:26:34 Eastern Standard Time using RSA key ID B1632E74
gpg: Can't check signature: No public key&lt;/code&gt;&lt;/pre&gt;
 &lt;p&gt;Oops, I got the wrong key. The message is signed with key &lt;code&gt;B1632E74&lt;/code&gt; (Andreas&amp;rsquo;s Blockchain.info key) so let&amp;rsquo;s get that one:&lt;/p&gt;
 &lt;pre&gt;&lt;code&gt;$ gpg2.exe" --keyserver pgp.mit.edu --recv-keys 0xB1632E74
gpg: requesting key B1632E74 from hkp server pgp.mit.edu
gpg: key B1632E74: public key "Andreas M. Antonopoulos (Blockchain.info CSO) &amp;lt;andreas@blockchain.info&amp;gt;" imported
gpg: no ultimately trusted keys found
gpg: Total number processed: 1
gpg:               imported: 1  (RSA: 1)&lt;/code&gt;&lt;/pre&gt;
 &lt;p&gt;And now let&amp;rsquo;s try to verify:&lt;/p&gt;
 &lt;pre&gt;&lt;code&gt;$ gpg2.exe" --verify andreas_fundraising_for_dorian.txt
gpg: Signature made 03/07/14 12:26:34 Eastern Standard Time using RSA key ID B1632E74
gpg: Good signature from "Andreas M. Antonopoulos (Blockchain.info CSO) &amp;lt;andreas@blockchain.info&amp;gt;"
gpg: WARNING: This key is not certified with a trusted signature!
gpg:          There is no indication that the signature belongs to the owner.
Primary key fingerprint: B40F E0EB 4316 82F5 A7BD  5B3B 339B 0210 B163 2E74&lt;/code&gt;&lt;/pre&gt;
 &lt;p&gt;Success!&lt;/p&gt;
 &lt;p&gt;One final issue. How do we know that &lt;em&gt;the&lt;/em&gt; Andreas Antonopoulos actually controls the &lt;code&gt;B1632E74&lt;/code&gt; key, and not someone posing as him, or someone else with the same name. As I mentioned in a &lt;a href="http://www.lostintransaction.com/blog/2014/03/05/verifying-hashes-and-signatures/" title="Post: Verifying Hashes and Signatures"&gt;previous post&lt;/a&gt;, there&amp;rsquo;s a few options:&lt;/p&gt;
 &lt;ol&gt;
  &lt;li&gt;
   &lt;p&gt;We can look in a central place that we trust. I checked &lt;a href="https://bitcoin.org/en"&gt;bitcoin.org&lt;/a&gt; and found the &lt;a href="https://bitcoin.org/en/development"&gt;PGP keys for several important people&lt;/a&gt; in the Bitcoin community. But no Andreas! I could not find anything on &lt;a href="https://blockchain.info"&gt;blockchain.info&lt;/a&gt; either.&lt;/p&gt;&lt;/li&gt;
  &lt;li&gt;
   &lt;p&gt;We can do an informal verification via &amp;ldquo;public consensus&amp;rdquo; by looking at &lt;a href="http://pgp.mit.edu/pks/lookup?op=vindex&amp;amp;search=0x339B0210B1632E74" title="Andreas Antonopoulos public key signatures"&gt;who else signed Andreas&amp;rsquo;s key&lt;/a&gt;. Unfortunately, there are not too many other signatures at the moment:&lt;/p&gt;
   &lt;pre&gt;&lt;code&gt;uid Andreas M. Antonopoulos (Blockchain.info CSO) &amp;lt;andreas@blockchain.info&amp;gt;
sig  sig3  B1632E74 2014-01-22 __________ 2015-01-22 [selfsig]
sig  sig   2878DE4F 2014-01-22 __________ __________ Andreas M. Antonopoulos &amp;lt;andreas@antonopoulos.com&amp;gt;
sig  sig   CF8338F5 2014-03-07 __________ __________ Christopher David Howie &amp;lt;me@chrishowie.com&amp;gt;&lt;/code&gt;&lt;/pre&gt;
   &lt;p&gt;Other than Andreas himself, there&amp;rsquo;s only one other person that is vouching for the key.&lt;/p&gt;&lt;/li&gt;
  &lt;li&gt;Luckily, Andreas anticipated this issue, and &lt;a href="http://www.youtube.com/watch?v=JCF1u1Wqfv0" title="Andreas PGP key YouTube video"&gt;issued a statement on YouTube&lt;/a&gt;, confirming his key. It&amp;rsquo;s a match! Now we are assured that the message is authentic.&lt;/li&gt;&lt;/ol&gt;&lt;/html&gt;</description></item>
  <item>
   <title>Verifying Hashes and Signatures</title>
   <link>http://www.lostintransaction.com/blog/2014/03/05/verifying-hashes-and-signatures/?utm_source=all&amp;utm_medium=RSS</link>
   <guid>urn:http-www-lostintransaction-com:-blog-2014-03-05-verifying-hashes-and-signatures</guid>
   <pubDate>Wed, 05 Mar 2014 06:44:02 UTC</pubDate>
   <description>
&lt;html&gt;&lt;img src="http://www.lostintransaction.com/img/1x1.gif?utm_source=all&amp;amp;utm_medium=RSS&amp;amp;utm_campaign=%2Fblog%2F2014%2F03%2F05%2Fverifying-hashes-and-signatures%2F" height="1" width="1" /&gt;
 &lt;p&gt;Security is really important when handling bitcoins. Hashes and signatures can help by verifying that you&amp;rsquo;re downloading what you think you&amp;rsquo;re downloading.&lt;/p&gt;
 &lt;p&gt;In this post, I briefly explain hashes and signatures, and then check the hash and signature of the MultiBit wallet program, essentially following &lt;a href="https://multibit.org/blog/2013/07/24/how-to-check-signatures.html" title="MultiBit tutorial on hashes and signatures"&gt;the MultiBit tutorial on hashes and signatures&lt;/a&gt;. All examples are run in Windows 7 (64-bit).&lt;/p&gt;
 &lt;h3 id="verifying-hashes"&gt;Verifying Hashes&lt;/h3&gt;
 &lt;h4 id="a-first-example"&gt;&lt;em&gt;A first example&lt;/em&gt;&lt;/h4&gt;
 &lt;p&gt;A hash function maps its input to a number. Any hash function may map various different inputs to the same number, but for certain &lt;a href="http://en.wikipedia.org/wiki/Cryptographic_hash_function" title="cryptographic hash function Wikipedia entry"&gt;&lt;em&gt;cryptographic&lt;/em&gt; hash functions&lt;/a&gt;, the probability of collision is so small that we can treat the hash function&amp;rsquo;s output as a unique identifier for the given input. The &lt;a href="http://en.wikipedia.org/wiki/SHA-1" title="SHA-1 Wikipedia entry"&gt;SHA&amp;ndash;1&lt;/a&gt; cryptographic hash function maps inputs to 160-bit numbers (40 hexadecial digits). Here&amp;rsquo;s the SHA&amp;ndash;1 hash (computed with Microsoft&amp;rsquo;s FCIV program) of the &lt;code&gt;"Hello world"&lt;/code&gt; example from the MultiBit tutorial:&lt;/p&gt;
 &lt;pre&gt;&lt;code&gt;$ echo "Hello world" &amp;gt; example.txt
$ fciv -sha1 example.txt
//
// File Checksum Integrity Verifier version 2.05.
//
25e64db6d4d1d6116ffe0b317918c98f3624cbed example.txt&lt;/code&gt;&lt;/pre&gt;
 &lt;p&gt;Note that in Windows, the resulting hash differs from the tutorial (ie, when using Linux) because the generated Windows &lt;code&gt;examples.txt&lt;/code&gt; file has extra quotes, an extra space, and uses the windows &lt;code&gt;\r\n&lt;/code&gt; end-of-line instead of &lt;code&gt;\n&lt;/code&gt;. We can easily simulate the Linux version though, to get the same hash from the tutorial. Here I use a &lt;a href="http://racket-lang.org"&gt;Racket&lt;/a&gt; script:&lt;/p&gt;
 &lt;pre class="brush: racket"&gt;&lt;code&gt;(with-output-to-file "example.txt" (lambda () (display "Hello world\n")) #:exists 'replace)&lt;/code&gt;&lt;/pre&gt;
 &lt;pre&gt;&lt;code&gt;$ racket
Welcome to Racket v6.0.0.3
&amp;gt; (with-output-to-file "example.txt" (lambda () (display "Hello world\n")) #:exists 'replace)
&amp;gt; (exit)
$ fciv -sha1 example.txt
//
// File Checksum Integrity Verifier version 2.05.
//
33ab5639bfd8e7b95eb1d8d0b87781d4ffea4d5d example.txt
&lt;/code&gt;&lt;/pre&gt;
 &lt;p&gt;&lt;a href="http://bitcoin.stackexchange.com/questions/14041/multibit-error-or-at-least-confusion-in-how-to-check-digital-signatures-in" title="Bitcoin StackExchange"&gt;It looks like I&amp;rsquo;m not the only person to notice the discrepancy&lt;/a&gt;.&lt;/p&gt;
 &lt;h4 id="computing-sha256"&gt;&lt;em&gt;Computing SHA&amp;ndash;256&lt;/em&gt;&lt;/h4&gt;
 &lt;p&gt;Most software you download from the internet should provide a hash that you can verify to make sure the file was not corrupted or altered. For example, Multibit provides &lt;a href="http://en.wikipedia.org/wiki/SHA-2" title="SHA-256 Wikipedia entry"&gt;SHA&amp;ndash;256 hashes&lt;/a&gt; (256-bit output) in &lt;a href="https://multibit.org/releases/multibit-0.5.17/release.txt" title="MultiBit 0.5.17 release notes"&gt;the release notes&lt;/a&gt; (SHA&amp;ndash;256 is also the main hash function used in the &lt;a href="https://en.bitcoin.it/wiki/Protocol_specification#Common_standards" title="Bitcoin protocol"&gt;Bitcoin protocol&lt;/a&gt;).&lt;/p&gt;
 &lt;p&gt;Since FCIV only computes SHA&amp;ndash;1, we need something else that computes SHA&amp;ndash;256. A quick Google search finds the &lt;a href="http://md5deep.sourceforge.net/"&gt;&lt;code&gt;md5deep&lt;/code&gt; library&lt;/a&gt;.&lt;/p&gt;
 &lt;p&gt;Since we are emphasizing security, let&amp;rsquo;s first make sure the program we just got is virus-free by &lt;a href="https://www.virustotal.com/en/file/eec0c765124b014c824db8759300f36b4a62b74ff81dfa68f77440389bb68d29/analysis/" title="sha256deep64.exe on virustotal"&gt;uploading to VirusTotal&lt;/a&gt;.&lt;/p&gt;
 &lt;p&gt;VirusTotal also uses SHA&amp;ndash;256, to track which files it has seen, and we can check that the file we uploaded, &lt;code&gt;sha256deep64.exe&lt;/code&gt;, matches the file for which VirusTotal is reporting results, by running it on itself:&lt;/p&gt;
 &lt;pre&gt;&lt;code&gt;$ sha256deep64 sha256deep64.exe
eec0c765124b014c824db8759300f36b4a62b74ff81dfa68f77440389bb68d29  sha256deep64.exe&lt;/code&gt;&lt;/pre&gt;
 &lt;p&gt;Interestingly, &lt;code&gt;sha256deep64.exe&lt;/code&gt; and &lt;code&gt;sha1deep64.exe&lt;/code&gt; produce the same SHA&amp;ndash;256 hash:&lt;/p&gt;
 &lt;pre&gt;&lt;code&gt;$ sha256deep64 sha1deep64.exe
eec0c765124b014c824db8759300f36b4a62b74ff81dfa68f77440389bb68d29  sha1deep64.exe&lt;/code&gt;&lt;/pre&gt;
 &lt;p&gt;No cause for concern though. Apparently this is &lt;a href="http://sourceforge.net/projects/md5deep/reviews/?offset=25" title="explanation of identical hash"&gt;intentional&lt;/a&gt; and the file determines its behavior based on its filename.&lt;/p&gt;
 &lt;h4 id="checking-multibits-hash"&gt;&lt;em&gt;Checking MultiBit&amp;rsquo;s hash&lt;/em&gt;&lt;/h4&gt;
 &lt;p&gt;Now we&amp;rsquo;re finally ready to check the hash of the MultiBit program, specifically version 0.5.17 for Windows.&lt;/p&gt;
 &lt;p&gt;From the &lt;a href="https://multibit.org/releases/multibit-0.5.17/release.txt" title="MultiBit 0.5.17 release notes"&gt;release notes&lt;/a&gt;:&lt;/p&gt;
 &lt;pre&gt;&lt;code&gt;SHA256 hashes for files:
90506bf43a64986ce8219ca0fb18a5e1f0776cfeb31043ca848cea7f71eda45d  multibit-0.5.17-windows-setup.exe&lt;/code&gt;&lt;/pre&gt;
 &lt;p&gt;Computing the hash of the downloaded file:&lt;/p&gt;
 &lt;pre&gt;&lt;code&gt;$ sha256deep64 multibit-0.5.17-windows-setup.exe
90506bf43a64986ce8219ca0fb18a5e1f0776cfeb31043ca848cea7f71eda45d  multibit-0.5.17-windows-setup.exe&lt;/code&gt;&lt;/pre&gt;
 &lt;p&gt;And it matches!&lt;/p&gt;
 &lt;h3 id="verifying-signatures"&gt;Verifying Signatures&lt;/h3&gt;
 &lt;h4 id="a-very-brief-introduction"&gt;&lt;em&gt;A very brief introduction&lt;/em&gt;&lt;/h4&gt;
 &lt;p&gt;Verifying the hash only ensures that nothing happened to the file during the download. For example, you can be pretty sure that no one intercepted your download and then sent you a hacked version. But what if the website you downloaded from was hacked in the first place, so both the file and the hash were fake?&lt;/p&gt;
 &lt;p&gt;This is where &lt;a href="http://en.wikipedia.org/wiki/Digital_signature" title="digital signature Wikipedia entry"&gt;digital signatures&lt;/a&gt; can help. Briefly, to prove that a file was not tampered with, the distributor of the file &amp;ldquo;signs&amp;rdquo; the file with a secret key that only they know. The distributor then posts the file, the signature, and a public key that is calculated from the private key. The downloader then uses the public key and signature to verify the downloaded file.&lt;/p&gt;
 &lt;p&gt;In a secure signature system, it&amp;rsquo;s impossible to determine the private key from the public key. Also, the verification process is only successful if the downloaded file was originally signed with the private key, which is only known by the distributor of the file. In other words, in a secure system, it&amp;rsquo;s computationally impossible to forge a valid signature without knowledge of the private key.&lt;/p&gt;
 &lt;h5 id="note"&gt;NOTE:&lt;/h5&gt;
 &lt;p&gt;Verifying a signature does not guarantee that the file you downloaded was not tampered with. If you don&amp;rsquo;t know the person distributing the file, then you might not be able to distinguish between a legitimate file-signature-public-key set from a bad one. However, a reliable signature system often relies on additional knowledge about the public key you are using.&lt;/p&gt;
 &lt;p&gt;For example, the public key could be confirmed by a central authority or key server that does additional checks to link keys to people. Or the other person, and their public key, may be well known, and so the &amp;ldquo;confirmation&amp;rdquo; in this case would be an informal public consensus. None of these methods guarantees authenticity, but they&amp;rsquo;re a lot more difficult to fool.&lt;/p&gt;
 &lt;h4 id="checking-multibits-signature"&gt;&lt;em&gt;Checking MultiBit&amp;rsquo;s signature&lt;/em&gt;&lt;/h4&gt;
 &lt;p&gt;&lt;a href="http://en.wikipedia.org/wiki/Pretty_Good_Privacy" title="PGP Wikipedia entry"&gt;PGP&lt;/a&gt; is a well-known signature system, which we&amp;rsquo;ll use to check verify MultiBit&amp;rsquo;s signature.&lt;/p&gt;
 &lt;ol&gt;
  &lt;li&gt;
   &lt;p&gt;First we download &lt;a href="http://www.gnupg.org/" title="GnuPG"&gt;GnuPG&lt;/a&gt;, &lt;a href="http://www.gnupg.org/" title="GnuPG for Windows"&gt;for Windows&lt;/a&gt;,  specifically Gpg4win-Vanilla, version 2.2.1. Of course we first  check the hash for a match.&lt;/p&gt;
   &lt;pre&gt;&lt;code&gt;$ sha1deep64 gpg4win-vanilla-2.2.1.exe
6d229b03ec2dcbb54a40f7590d108dc0cbcb5aac  gpg4win-vanilla-2.2.1.exe&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
  &lt;li&gt;
   &lt;p&gt;Then, following the MultiBit tutorial, we get the public key for  Jim Burton, MultiBit developer, from a known key server.&lt;/p&gt;
   &lt;pre&gt;&lt;code&gt;$ gpg2.exe" --keyserver pgp.mit.edu -- recv-keys 0x79F7C572
gpg: requesting key 79F7C572 from hkp server pgp.mit.edu
gpg: .../AppData/Roaming/gnupg/trustdb.gpg: trustdb created
gpg: key 79F7C572: public key "Jim Burton (multibit.org developer) &amp;lt;jim618@fastmail.co.uk&amp;gt;" imported
gpg: no ultimately trusted keys found
gpg: Total number processed: 1
gpg:               imported: 1  (RSA: 1)&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
  &lt;li&gt;
   &lt;p&gt;Then we download the &lt;a href="https://multibit.org/releases/multibit-0.5.17/multibit-0.5.17-windows-setup.exe.asc" title="MultiBit signature file"&gt;signature file&lt;/a&gt;.&lt;/p&gt;&lt;/li&gt;
  &lt;li&gt;
   &lt;p&gt;Finally, we can verify that Jim signed the file we&amp;rsquo;re downloading  and that it hasn&amp;rsquo;t been tampered with.&lt;/p&gt;
   &lt;pre&gt;&lt;code&gt;$ gpg2.exe" --verify multibit-0.5.17-windows-setup.exe.asc
gpg: Signature made 03/03/14 06:09:34 Eastern Standard Time using RSA key ID 23F7FB7B
gpg: Good signature from "Jim Burton (multibit.org developer) &amp;lt;jim618@fastmail.co.uk&amp;gt;"
gpg: WARNING: This key is not certified with a trusted signature!
gpg:          There is no indication that the signature belongs to the owner.
Primary key fingerprint: 299C 423C 672F 47F4 756A  6BA4 C197 2AED 79F7 C572
     Subkey fingerprint: 4A71 A836 F572 01B4 D088  7D60 0820 A658 23F7 FB7B&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;&lt;/ol&gt;
 &lt;p&gt;The warning means that we have never seen Jim&amp;rsquo;s public key, and nor has anyone that we trust (the &lt;code&gt;gpg&lt;/code&gt; program keeps track of people we trust, which is no one at the moment). This key server uses the &lt;a href="http://en.wikipedia.org/wiki/Web_of_trust" title="web of trust Wikipedia entry"&gt;public consensus confirmation strategy&lt;/a&gt; described above. Here, a person&amp;rsquo;s public key can be signed by others and in this way, these other people vouch that this is indeed Jim&amp;rsquo;s key. Of course, it could still be that lots of people have teamed up to deceive you, and have signed a fake version of Jim&amp;rsquo;s key. As the key accumulates more signatures, however, the likelihood that it is fake does down.&lt;/p&gt;&lt;/html&gt;</description></item></channel></rss>