<?xml version="1.0" encoding="utf-8"?> 
<rss version="2.0">
 <channel>
  <title>Lost in Transaction: A neophyte explores Bitcoin: All Posts</title>
  <description>Lost in Transaction: A neophyte explores Bitcoin: All Posts</description>
  <link>http://www.lostintransaction.com/index.html</link>
  <lastBuildDate>Thu, 17 Apr 2014 03:43:06 UTC</lastBuildDate>
  <pubDate>Thu, 17 Apr 2014 03:43:06 UTC</pubDate>
  <ttl>1800</ttl>
  <item>
   <title>Generating a Vanity Address</title>
   <link>http://www.lostintransaction.com/blog/2014/04/17/generating-a-vanity-address/?utm_source=all&amp;utm_medium=RSS</link>
   <guid>urn:http-www-lostintransaction-com:-blog-2014-04-17-generating-a-vanity-address</guid>
   <pubDate>Thu, 17 Apr 2014 03:43:06 UTC</pubDate>
   <description>
&lt;html&gt;&lt;img src="http://www.lostintransaction.com/img/1x1.gif?utm_source=all&amp;amp;utm_medium=RSS&amp;amp;utm_campaign=%2Fblog%2F2014%2F04%2F17%2Fgenerating-a-vanity-address%2F" height="1" width="1" /&gt;
 &lt;p&gt;It a &lt;a href="http://www.lostintransaction.com/blog/2014/03/14/computing-a-bitcoin-address-part-1-private-to-public-key/" title="Computing a Bitcoin Address"&gt;previous series of posts&lt;/a&gt;, we figured out how to derive a Bitcoin public address from a private key. What should we do with this new knowledge? Let&amp;rsquo;s generate a bunch of addresses! Specifically, we&amp;rsquo;ll create a &amp;ldquo;vanity&amp;rdquo; address generator.&lt;/p&gt;
 &lt;p&gt;Most Bitcoin wallets generate addresses randomly. A Bitcoin &lt;a href="https://en.bitcoin.it/wiki/Vanitygen" title="Vanitygen"&gt;vanity address&lt;/a&gt;, however, is one that has a prefix specified by the user. Of course, you don&amp;rsquo;t want to trust a third party to create a private key for you, so let&amp;rsquo;s generate our own. (Yes, I know that &lt;code&gt;vanitygen&lt;/code&gt; is open source and has tons more features but it&amp;rsquo;s still more fun to roll our own!) As usual, I&amp;rsquo;ll be using &lt;a href="http://racket-lang.org"&gt;Racket&lt;/a&gt;.&lt;/p&gt;
 &lt;p&gt;First, we need to generate a random private key. Bitcoin private keys are 32 bytes long.&lt;/p&gt;
 &lt;pre class="brush: racket"&gt;&lt;code&gt;(define (random-byte) (random 256))

;; generates raw 32 byte private key (in hex)
(define (random-priv-key)
  (bytes-&amp;gt;hex-string (apply bytes (for/list ([i 32]) (random-byte)))))&lt;/code&gt;&lt;/pre&gt;
 &lt;blockquote&gt;
  &lt;p&gt;WARNING #1: Racket&amp;rsquo;s &lt;code&gt;random&lt;/code&gt; function is  &lt;a href="http://docs.racket-lang.org/reference/generic-numbers.html?q=make-pseudo-random-generator#%28def._%28%28quote._~23~25kernel%29._make-pseudo-random-generator%29%29" title="Racket docs: make-pseudo-random-generator"&gt;seeded with the system time&lt;/a&gt; and is thus not  &lt;a href="https://cwe.mitre.org/data/definitions/337.html"&gt;completely random&lt;/a&gt;. I  believe something like &lt;code&gt;/dev/random&lt;/code&gt; is a more  &lt;a href="http://en.wikipedia.org/wiki/Cryptographically_secure_pseudorandom_number_generator" title="Wikipedia: Cryptographically secure pseudorandom number generator"&gt;cryptographically secure source of randomness&lt;/a&gt;, when  generating addresses for real-world use.&lt;/p&gt;&lt;/blockquote&gt;
 &lt;blockquote&gt;
  &lt;p&gt;WARNING #2:  &lt;a href="https://en.bitcoin.it/wiki/Private_key#Range_of_valid_private_keys" title="Range of valid private keys"&gt;Not every 32 byte number is a valid private key&lt;/a&gt;. I  assume that it&amp;rsquo;s sufficiently unlikely that I&amp;rsquo;ll randomly generate  an invalid key, so I ignore this issue here.&lt;/p&gt;&lt;/blockquote&gt;
 &lt;p&gt;Once we have a private key, we need to convert to &lt;a href="https://en.bitcoin.it/wiki/WIF" title="Wallet import format"&gt;wallet import format (WIF)&lt;/a&gt;. To do this we need to decide if we want a compressed or uncompressed address. These days most addresses in use are compressed so we&amp;rsquo;ll go with compressed. The format for a compressed WIF private key is:&lt;/p&gt;
 &lt;pre&gt;&lt;code&gt;0x80 + 32 byte raw private key + 0x10 + 4 byte checksum&lt;/code&gt;&lt;/pre&gt;
 &lt;p&gt;To create a WIF private key we append &lt;code&gt;0x80&lt;/code&gt; to the front of our randomly generated raw private key to indicate &amp;ldquo;mainnet&amp;rdquo; (as opposed to &amp;ldquo;testnet&amp;rdquo;) and we append &lt;code&gt;0x01&lt;/code&gt; to the end to indicate compression. We then compute a checksum for this string and append that to the end of the string. A checksum is the first 4 bytes of a double SHA&amp;ndash;256 hash, as we &lt;a href="http://www.lostintransaction.com/blog/2014/04/09/computing-a-bitcoin-address-part-4-wallet-import-format-wif/" title="Computing a Bitcoin Address, Part 4: Wallet Import Format (WIF)"&gt;saw previously&lt;/a&gt;.&lt;/p&gt;
 &lt;p&gt;Here&amp;rsquo;s a Racket function &lt;code&gt;priv-key-&amp;gt;wif/compressed&lt;/code&gt; to convert a raw private key to wallet import format. We use &lt;code&gt;add-checksum&lt;/code&gt; from &lt;a href="http://www.lostintransaction.com/blog/2014/04/09/computing-a-bitcoin-address-part-4-wallet-import-format-wif/" title="Computing a Bitcoin Address, Part 4: Wallet Import Format (WIF)"&gt;a previous post&lt;/a&gt;.&lt;/p&gt;
 &lt;pre class="brush: racket"&gt;&lt;code&gt;(define (add-mainnet80 str) (string-append "80" str))
(define (add-compression-flag str) (string-append str "01"))
;; converts raw priv key (in hex) to wif (in base58)
(define (priv-key-&amp;gt;wif/compressed priv)
  (hex-str-&amp;gt;base58-str (add-checksum (add-compression-flag (add-mainnet80 priv)))))&lt;/code&gt;&lt;/pre&gt;
 &lt;p&gt;To generate a random address, we use the functions defined in this post, and &lt;code&gt;wif-&amp;gt;addr&lt;/code&gt; &lt;a href="http://www.lostintransaction.com/blog/2014/04/09/computing-a-bitcoin-address-part-4-wallet-import-format-wif/" title="Computing a Bitcoin Address, Part 4: Wallet Import Format (WIF)"&gt;from a previous post&lt;/a&gt;, which converts a WIF private key to an address. To get a vanity address, we check if the prefix of the generated address matches a specified substring (all Bitcoin addresses start with &amp;lsquo;1&amp;rsquo;, so prefix here means the substring after the &amp;lsquo;1&amp;rsquo;).&lt;/p&gt;
 &lt;p&gt;The following Racket function &lt;code&gt;get-vanity-addr&lt;/code&gt; repeatedly generates a random private key, converts it to an address, and checks if the prefix of the address matches the input &amp;ldquo;vanity&amp;rdquo; substring. If no matching address is found after the specified number of &lt;code&gt;tries&lt;/code&gt; (default is 1,000,000 tries), the function gives up. Otherwise, the function returns the raw private key, the WIF private key, and the public address.&lt;/p&gt;
 &lt;pre class="brush: racket"&gt;&lt;code&gt;(define (get-vanity-addr prefix #:tries [tries 1000000])
  (define prefix1 (string-append "1" prefix))
  (define prefix-len (string-length prefix1))
  (let loop ([n tries])
    (if (zero? n)
    (printf "\nCouldn't find matching address in ~a tries\n" tries)
    (let* ([priv (random-priv-key)]
           [priv/wif (priv-key-&amp;gt;wif/compressed priv)]
           [addr (wif-&amp;gt;addr priv/wif)])
      (if (string=? (substring addr 0 prefix-len) prefix1)
          (values priv priv/wif addr)
          (loop (sub1 n)))))))&lt;/code&gt;&lt;/pre&gt;
 &lt;p&gt;Let&amp;rsquo;s try it. I specify a prefix of &amp;ldquo;11&amp;rdquo;, so the function tries to find an address with three leading &amp;rsquo;1&amp;rsquo;s:&lt;/p&gt;
 &lt;pre&gt;&lt;code&gt;$ racket
Welcome to Racket v6.0.0.3.
-&amp;gt; (require "vanity.rkt")
-&amp;gt; (get-vanity-addr "11")
Address found! -----------------------------------------------
private key: 286a5cdfb346648b902fe30c46e2f44246d9071ab5ddcf2fb6101a657cbc18de
private key (WIF): KxaGocHndfhXzPGdrDTfr6EDvnNfbdZwdxcX7xtjL6UnERFZhtkZ
public address: 111ksvuJkfkFef8krFpsUeKDrCSedKpxM
&lt;/code&gt;&lt;/pre&gt;
 &lt;p&gt;We found an address! To check that it&amp;rsquo;s a valid address, I sent some BTC to the address to confirm. Lo and behold, &lt;a href="https://blockchain.info/address/111ksvuJkfkFef8krFpsUeKDrCSedKpxM" title="blockchain.info"&gt;the transactions appear in the blockchain&lt;/a&gt;!&lt;/p&gt;
 &lt;p&gt;Next I imported the WIF private key into MultiBit. MultiBit requires that the key be accompanied by a time in UTC format and saved to a file so here&amp;rsquo;s the contents of the file I created and imported into MultiBit:&lt;/p&gt;
 &lt;pre&gt;&lt;code&gt;KxaGocHndfhXzPGdrDTfr6EDvnNfbdZwdxcX7xtjL6UnERFZhtkZ 2014-04-15T06:12:28Z&lt;/code&gt;&lt;/pre&gt;
 &lt;p&gt;To make sure the import succeeded, I spent the BTC that I just received. &lt;a href="https://blockchain.info/address/111ksvuJkfkFef8krFpsUeKDrCSedKpxM" title="blockchain.info"&gt;Checking the blockchain again&lt;/a&gt;, we can see that sending BTC from our generated address worked as well!&lt;/p&gt;
 &lt;h3 id="software"&gt;Software&lt;/h3&gt;
 &lt;p&gt;All the code from this post &lt;a href="http://www.lostintransaction.com/code/vanity.rkt"&gt;is available here&lt;/a&gt;. In this post, I&amp;rsquo;m using Racket 6.0.0.3 running in Debian 7.0, and MultiBit 0.5.17 running in Windows 7 64-bit.&lt;/p&gt;&lt;/html&gt;</description></item>
  <item>
   <title>Computing a Bitcoin Address, Part 4: Wallet Import Format (WIF)</title>
   <link>http://www.lostintransaction.com/blog/2014/04/09/computing-a-bitcoin-address-part-4-wallet-import-format-wif/?utm_source=all&amp;utm_medium=RSS</link>
   <guid>urn:http-www-lostintransaction-com:-blog-2014-04-09-computing-a-bitcoin-address-part-4-wallet-import-format-wif</guid>
   <pubDate>Wed, 09 Apr 2014 03:02:03 UTC</pubDate>
   <description>
&lt;html&gt;&lt;img src="http://www.lostintransaction.com/img/1x1.gif?utm_source=all&amp;amp;utm_medium=RSS&amp;amp;utm_campaign=%2Fblog%2F2014%2F04%2F09%2Fcomputing-a-bitcoin-address-part-4-wallet-import-format-wif%2F" height="1" width="1" /&gt;
 &lt;p&gt;In previous posts, we figured out how to compute a Bitcoin address from a private key and we tested our code with an &lt;a href="https://en.bitcoin.it/wiki/Technical_background_of_version_1_Bitcoin_addresses" title="Bitcoin wiki: Bitcoin addresses"&gt;example from the Bitcoin wiki&lt;/a&gt;. In this post we try to convert a private key from a real wallet (MultiBit) to its corresponding address.&lt;/p&gt;
 &lt;blockquote&gt;
  &lt;p&gt;This is the fourth post in a four-part series titled &amp;ldquo;Computing a Bitcoin Address&amp;rdquo;. Here are all the articles in the series:&lt;/p&gt;
  &lt;ul&gt;
   &lt;li&gt;Part 1: &lt;a href="http://www.lostintransaction.com/blog/2014/03/14/computing-a-bitcoin-address-part-1-private-to-public-key/"&gt;Private to Public Key&lt;/a&gt;&lt;/li&gt;
   &lt;li&gt;Part 2: &lt;a href="http://www.lostintransaction.com/blog/2014/03/15/computing-a-bitcoin-address-part-2-public-key-to-hex-address/"&gt;Public Key to (Hex) Address&lt;/a&gt;&lt;/li&gt;
   &lt;li&gt;Part 3: &lt;a href="http://www.lostintransaction.com/blog/2014/03/18/computing-a-bitcoin-address-part-3-base58check-encoding/"&gt;Base58Check Encoding&lt;/a&gt;&lt;/li&gt;
   &lt;li&gt;Part 4: &lt;a href="http://www.lostintransaction.com/blog/2014/04/09/computing-a-bitcoin-address-part-4-wallet-import-format-wif/"&gt;Wallet Import Format (WIF)&lt;/a&gt; (this post)&lt;/li&gt;&lt;/ul&gt;&lt;/blockquote&gt;
 &lt;h3 id="from-private-key-to-public-address"&gt;From Private Key to Public Address&lt;/h3&gt;
 &lt;p&gt;Let&amp;rsquo;s consolidate the code from the previous posts to create one function that performs all the steps to convert a private key (in hex) to a public address (in Base58Check). First we create some helper functions:&lt;/p&gt;
 &lt;pre class="brush: racket"&gt;&lt;code&gt;(define (hash160/hex hstr) (ripemd160/hex (sha256/hex hstr)))
(define (sha256x2/hex hstr) (sha256/hex (sha256/hex hstr)))
(define (add-version0 str) (string-append "00" str))
;; checksum is 1st 4 bytes (8 chars) of double sha256 hash of given hex string
(define (get-checksum hstr) (substring hstr 0 8))
(define (compute-checksum hstr) (get-checksum (sha256x2/hex hstr)))
(define (add-checksum hstr) (string-append hstr (compute-checksum hstr)))&lt;/code&gt;&lt;/pre&gt;
 &lt;ul&gt;
  &lt;li&gt;&lt;code&gt;hash160/hex&lt;/code&gt;: performs a SHA&amp;ndash;256 hash followed by a RIPEMD&amp;ndash;160 hash on an input hex string&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;sha256x2/hex&lt;/code&gt;: performs SHA&amp;ndash;256 twice on an input hex string&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;add-version0&lt;/code&gt;: prepends &lt;code&gt;0x00&lt;/code&gt; to a hex string&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;compute-checksum&lt;/code&gt;: computes the checksum (first 4 bytes of a double SHA&amp;ndash;245 hash) of its input&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;add-checksum&lt;/code&gt;: computes the checksum for its input and appends that checksum to the end of the input&lt;/li&gt;&lt;/ul&gt;
 &lt;p&gt;Here&amp;rsquo;s a function &lt;code&gt;priv-key-&amp;gt;addr&lt;/code&gt; that converts a private key (in hex) to a public address (in Base58Check):&lt;/p&gt;
 &lt;pre class="brush: racket"&gt;&lt;code&gt;;; computes base58 addr from hex priv key
(define priv-key-&amp;gt;addr
  (compose hex-str-&amp;gt;base58-str
           add-checksum
           add-version0
           hash160/hex
           priv-key-&amp;gt;pub-key))&lt;/code&gt;&lt;/pre&gt;
 &lt;p&gt;We use Racket&amp;rsquo;s &lt;code&gt;compose&lt;/code&gt; function, which strings together a series of functions. The functions are called in the reverse order in which they are listed, so &lt;code&gt;priv-key-&amp;gt;addr&lt;/code&gt; first calls &lt;code&gt;priv-key-&amp;gt;pub-key&lt;/code&gt; on its input, then takes that result and gives it to &lt;code&gt;hash160/hex&lt;/code&gt;, and so on.&lt;/p&gt;
 &lt;p&gt;Let&amp;rsquo;s test our function on &lt;a href="https://en.bitcoin.it/wiki/Technical_background_of_version_1_Bitcoin_addresses" title="Bitcoin wiki: Bitcoin addresses"&gt;this Bitcoin wiki example&lt;/a&gt;:&lt;/p&gt;
 &lt;ul&gt;
  &lt;li&gt;private key: &lt;code&gt;18E14A7B6A307F426A94F8114701E7C8E774E7F9A47E2C2035DB29A206321725&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;public address: &lt;code&gt;16UwLL9Risc3QfPqBUvKofHmBQ7wMtjvM&lt;/code&gt;&lt;/li&gt;&lt;/ul&gt;
 &lt;p&gt;We save the code to the file &lt;code&gt;priv2addr.rkt&lt;/code&gt; and use &lt;a href="http://docs.racket-lang.org/xrepl/index.html"&gt;Racket&amp;rsquo;s extended REPL&lt;/a&gt;:&lt;/p&gt;
 &lt;pre&gt;&lt;code&gt;$ racket
Welcome to Racket v6.0.0.3.
-&amp;gt; (require "priv2addr.rkt")
-&amp;gt; (define priv-key "18E14A7B6A307F426A94F8114701E7C8E774E7F9A47E2C2035DB29A206321725")
-&amp;gt; (priv-key-&amp;gt;addr priv-key)
"16UwLL9Risc3QfPqBUvKofHmBQ7wMtjvM"&lt;/code&gt;&lt;/pre&gt;
 &lt;h3 id="a-multibit-wallet"&gt;A MultiBit Wallet&lt;/h3&gt;
 &lt;p&gt;Now let&amp;rsquo;s test our function on a real private key. I created a new wallet in MultiBit and it generated address &lt;code&gt;1G9dbCmxtbaBQACVgcHWHJgyr8ZNCiVL9j&lt;/code&gt;. I then exported the private key associated with this address into a file. Here&amp;rsquo;s the contents of that file:&lt;/p&gt;
 &lt;pre&gt;&lt;code&gt;# KEEP YOUR PRIVATE KEYS SAFE !
# Anyone who can read this file can spend your bitcoin.
#
# Format:
#   &amp;lt;Base58 encoded private key&amp;gt;[&amp;lt;whitespace&amp;gt;[&amp;lt;key createdAt&amp;gt;]]
#
#   The Base58 encoded private keys are the same format as
#   produced by the Satoshi client/ sipa dumpprivkey utility.
#
#   Key createdAt is in UTC format as specified by ISO 8601
#   e.g: 2011-12-31T16:42:00Z . The century, 'T' and 'Z' are mandatory
#
L3S9k3w3gMj2gBUWvPQQTC74giRTjQU3EEXF51f17qQskgJsF7Qe` 2014-03-10T06:12:28Z
# End of private keys&lt;/code&gt;&lt;/pre&gt;
 &lt;p&gt;Let&amp;rsquo;s see if our function can convert this private key to its public address.&lt;/p&gt;
 &lt;ul&gt;
  &lt;li&gt;private key: &lt;code&gt;L3S9k3w3gMj2gBUWvPQQTC74giRTjQU3EEXF51f17qQskgJsF7Qe&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;public address: &lt;code&gt;1G9dbCmxtbaBQACVgcHWHJgyr8ZNCiVL9j&lt;/code&gt;&lt;/li&gt;&lt;/ul&gt;
 &lt;p&gt;The key is in base&amp;ndash;58 so we need to first convert it to hex.&lt;/p&gt;
 &lt;pre&gt;&lt;code&gt;$ racket
Welcome to Racket v6.0.0.3.
-&amp;gt; (require "priv2addr.rkt" "base58.rkt")
-&amp;gt; (define priv/base58 "L3S9k3w3gMj2gBUWvPQQTC74giRTjQU3EEXF51f17qQskgJsF7Qe")
-&amp;gt; (define priv/hex (base58-str-&amp;gt;hex-str priv/base58))
-&amp;gt; (priv-key-&amp;gt;addr priv/hex)
"1GoZxLR83RfoZeqzNSdTZuEb4vHAc6zFfc"
&lt;/code&gt;&lt;/pre&gt;
 &lt;p&gt;Hmm, we get the wrong address! Querying the private key at &lt;a href="http://bitaddress.org"&gt;bitaddress.org&lt;/a&gt; reveals that the private key is&lt;/p&gt;
 &lt;ol&gt;
  &lt;li&gt;in &lt;a href="https://en.bitcoin.it/wiki/Wallet_import_format" title="Wallet import format"&gt;Wallet Import Format (WIF)&lt;/a&gt;, and&lt;/li&gt;
  &lt;li&gt;in &lt;a href="https://en.bitcoin.it/wiki/Private_key"&gt;&amp;ldquo;compressed&amp;rdquo; form&lt;/a&gt;.&lt;/li&gt;&lt;/ol&gt;
 &lt;p&gt;&amp;ldquo;Compressed&amp;rdquo; is in quotes because the private key itself is not compressed, but rather has a flag that indicates that the public key should be compressed. Here&amp;rsquo;s the relevant details of the Wallet Import Format (WIF):&lt;/p&gt;
 &lt;p&gt;&amp;ldquo;Uncompressed&amp;rdquo; WIF private key:&lt;/p&gt;
 &lt;pre&gt;&lt;code&gt;0x80 + 32 byte raw private key + 4 byte checksum
&lt;/code&gt;&lt;/pre&gt;
 &lt;p&gt;&amp;ldquo;Compressed&amp;rdquo; WIF private key:&lt;/p&gt;
 &lt;pre&gt;&lt;code&gt;0x80 + 32 byte raw private key + 0x01 + 4 byte checksum
&lt;/code&gt;&lt;/pre&gt;
 &lt;p&gt;The &lt;code&gt;0x80&lt;/code&gt; prefix indicates an address on the main Bitcoin blockchain (as opposed to the testnet). The &amp;ldquo;compressed&amp;rdquo; form has an extra &lt;code&gt;0x01&lt;/code&gt; byte before the checksum.&lt;/p&gt;
 &lt;h3 id="wif-checksum-checking"&gt;WIF Checksum Checking&lt;/h3&gt;
 &lt;p&gt;Before converting the WIF private key to an address, let&amp;rsquo;s first write a function that checks the checksum for a WIF private key. To do this we need a predicate that determines if the compressed flag is set in a WIF private key:&lt;/p&gt;
 &lt;pre class="brush: racket"&gt;&lt;code&gt;;; wif is in base58
(define (wif-compressed? wif)
  (define len (string-length wif))
  (when (not (or (= len 51) (= len 52)))
    (error 'wif-compressed? "invalid WIF: ~a\n" wif))
  (define c (string-ref wif 0))
  (or (char=? c #\K) (char=? c #\L)))&lt;/code&gt;&lt;/pre&gt;
 &lt;p&gt;A WIF private key with the comrpession flag set begins with a &lt;code&gt;K&lt;/code&gt; or &lt;code&gt;L&lt;/code&gt; and &lt;code&gt;wif-compressed?&lt;/code&gt; checks for this.&lt;/p&gt;
 &lt;p&gt;Next we define a predicate that verifies a WIF private key&amp;rsquo;s checksum. The checksum is again computed with a double SHA&amp;ndash;256.&lt;/p&gt;
 &lt;pre class="brush: racket"&gt;&lt;code&gt;;; splits wif into prefix + checksum
;; wif is in base58 but results are in  hex
(define (wif-split-checksum wif)
  (define wif/hex (base58-str-&amp;gt;hex-str wif))
  (cond [(wif-compressed? wif)
         (values (substring wif/hex 0 68) (substring wif/hex 68 76))]
        [else
         (values (substring wif/hex 0 66) (substring wif/hex 66 74))]))

(define (hex=? str1 str2) (string=? (string-upcase str1) (string-upcase str2)))

;; wif is in base58
(define (wif-checksum-ok? wif)
  (define-values (wif-prefix wif-checksum) (wif-split-checksum wif))
  (hex=? wif-checksum (compute-checksum wif-prefix)))&lt;/code&gt;&lt;/pre&gt;
 &lt;p&gt;First, &lt;code&gt;wif-checksum-ok?&lt;/code&gt; calls &lt;code&gt;wif-split-checksum&lt;/code&gt; to split a WIF private key into a prefix and a checksum. Then, &lt;code&gt;wif-checksum-ok?&lt;/code&gt; computes a double SHA&amp;ndash;256 on the prefix and verifies that it matches the checksum.&lt;/p&gt;
 &lt;p&gt;Let&amp;rsquo;s try these functions on our example:&lt;/p&gt;
 &lt;pre&gt;&lt;code&gt;$ racket
Welcome to Racket v6.0.0.3.
-&amp;gt; (define wif/comp "L3S9k3w3gMj2gBUWvPQQTC74giRTjQU3EEXF51f17qQskgJsF7Qe")
-&amp;gt; (wif-checksum-ok? wif/comp)
#t
&lt;/code&gt;&lt;/pre&gt;
 &lt;p&gt;We can also try on the &amp;ldquo;uncompressed&amp;rdquo; version of the same private key, which according to &lt;a href="https://www.bitaddress.org"&gt;bitaddress.org&lt;/a&gt;, is &lt;code&gt;5KDwznXNT8sJbhtYheFNB1ho9Yb69hfJGgmTkW9cNVBr7LxFEje&lt;/code&gt;.&lt;/p&gt;
 &lt;pre&gt;&lt;code&gt;-&amp;gt; (define wif/uncomp "5KDwznXNT8sJbhtYheFNB1ho9Yb69hfJGgmTkW9cNVBr7LxFEje")
-&amp;gt; (wif-checksum-ok? wif/uncomp)
#t
&lt;/code&gt;&lt;/pre&gt;
 &lt;h3 id="from-wif-private-key-to-address"&gt;From WIF Private Key to Address&lt;/h3&gt;
 &lt;p&gt;To convert from a WIF private key to an address, we need to:&lt;/p&gt;
 &lt;ol&gt;
  &lt;li&gt;decide whether the compression flag is set in the WIF private key,&lt;/li&gt;
  &lt;li&gt;extract the raw private key, and&lt;/li&gt;
  &lt;li&gt;compute either an uncompressed or compressed Bitcoin address.&lt;/li&gt;&lt;/ol&gt;
 &lt;p&gt;We have already defined code for step 1. For step 2, we just drop all prefixes and checksums from the WIF private key:&lt;/p&gt;
 &lt;pre class="brush: racket"&gt;&lt;code&gt;;; wif is in base58, priv key is in hex
(define (wif-&amp;gt;priv-key wif) (substring (base58-str-&amp;gt;hex-str wif) 2 66))&lt;/code&gt;&lt;/pre&gt;
 &lt;p&gt;To verify that our funtion properly extracts the raw private key, let&amp;rsquo;s take our MultiBit-generated private key &lt;code&gt;L3S9k3w3gMj2gBUWvPQQTC74giRTjQU3EEXF51f17qQskgJsF7Qe&lt;/code&gt; and compute the hash160 value (using &lt;code&gt;hash160/hex&lt;/code&gt; defined above). &lt;a href="https://blockchain.info/address/1G9dbCmxtbaBQACVgcHWHJgyr8ZNCiVL9j" title="blockchain.info 1G9dbCmxtbaBQACVgcHWHJgyr8ZNCiVL9j"&gt;According to blockchain.info&lt;/a&gt;, the hash160 value should be &lt;code&gt;a62bc20c511af7160a6150a72042b3fff8a86646&lt;/code&gt;. The &lt;code&gt;^&lt;/code&gt; token in the &lt;a href="http://docs.racket-lang.org/xrepl/index.html"&gt;Racket XREPL&lt;/a&gt; is bound to the last printed value.&lt;/p&gt;
 &lt;pre&gt;&lt;code&gt;$ racket Welcome to Racket v6.0.0.3.  -&amp;gt; (require "priv2addr.rkt"
"priv2pub.rkt") -&amp;gt; (define wif
"L3S9k3w3gMj2gBUWvPQQTC74giRTjQU3EEXF51f17qQskgJsF7Qe") -&amp;gt;
(wif-&amp;gt;priv-key wif)
"B96CA0C6390D4734C80A44ECD4ACEF21E2886BA250EC1D8CF461F1C94FAE6EA9"
-&amp;gt; (priv-key-&amp;gt;pub-key/compressed ^)
"036eef34887c91e2ed2815de2192bd541867708bb1c7434cd571073ddecaaafc42"
-&amp;gt; (hash160/hex ^) "a62bc20c511af7160a6150a72042b3fff8a86646"&lt;/code&gt;&lt;/pre&gt;
 &lt;p&gt;Since the private key begins with &lt;code&gt;L&lt;/code&gt;, we know that the compression flag is set so we use &lt;code&gt;priv-key-&amp;gt;pub-key/compressed&lt;/code&gt;, &lt;a href="http://www.lostintransaction.com/blog/2014/03/14/computing-a-bitcoin-address-part-1-private-to-public-key/" title="Computing a Bitcoin Address, Part 1: Private to Public Key"&gt;defined in a previous post&lt;/a&gt;, to get the compressed public key, which we give to &lt;code&gt;hash160/hex&lt;/code&gt; to get the hash160 value.&lt;/p&gt;
 &lt;p&gt;For step 3, we already defined &lt;code&gt;priv-key-&amp;gt;addr&lt;/code&gt; above, which computes an uncompressed address, so we just need a version that computes a compressed address. Here&amp;rsquo;s &lt;code&gt;priv-key-&amp;gt;addr/compressed&lt;/code&gt;, which uses &lt;code&gt;priv-key-&amp;gt;pub-key/compressed&lt;/code&gt;:&lt;/p&gt;
 &lt;pre class="brush: racket"&gt;&lt;code&gt;;; computes base58 addr from compressed (hex) priv key
(define priv-key-&amp;gt;addr/compressed
  (compose hex-str-&amp;gt;base58-str
           add-checksum
           add-version0
           hash160/hex
           priv-key-&amp;gt;pub-key/compressed))&lt;/code&gt;&lt;/pre&gt;
 &lt;p&gt;Finally, we can define &lt;code&gt;wif-&amp;gt;addr&lt;/code&gt;, which converts a WIF private key to a Bitcoin address:&lt;/p&gt;
 &lt;pre class="brush: racket"&gt;&lt;code&gt;;; wif and addr are base58
(define (wif-&amp;gt;addr wif)
  (define priv (wif-&amp;gt;priv-key wif))
  (if (wif-compressed? wif)
      (priv-key-&amp;gt;addr/compressed priv)
      (priv-key-&amp;gt;addr priv)))&lt;/code&gt;&lt;/pre&gt;
 &lt;p&gt;Let&amp;rsquo;s test this code with the MultiBit wallet example from above. Here are the WIF private keys, both with compressed flag set and unset, and their associated public addresses:&lt;/p&gt;
 &lt;ul&gt;
  &lt;li&gt;WIF private key, compressed: &lt;code&gt;L3S9k3w3gMj2gBUWvPQQTC74giRTjQU3EEXF51f17qQskgJsF7Qe&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;public address, compressed: &lt;code&gt;1G9dbCmxtbaBQACVgcHWHJgyr8ZNCiVL9j&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;WIF private key, uncompressed: &lt;code&gt;5KDwznXNT8sJbhtYheFNB1ho9Yb69hfJGgmTkW9cNVBr7LxFEje&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;public address, uncompressed: &lt;code&gt;15YzfXwEg5STm3GtEh87LAyzNbpVpdx5eN&lt;/code&gt;&lt;/li&gt;&lt;/ul&gt;
 &lt;p&gt;Let&amp;rsquo;s test that our code gives the expected results:&lt;/p&gt;
 &lt;pre&gt;&lt;code&gt;$ racket
Welcome to Racket v6.0.0.3.
-&amp;gt; (require "priv2addr.rkt")
-&amp;gt; (define wif/comp "L3S9k3w3gMj2gBUWvPQQTC74giRTjQU3EEXF51f17qQskgJsF7Qe")
-&amp;gt; (wif-&amp;gt;addr wif/comp)
"1G9dbCmxtbaBQACVgcHWHJgyr8ZNCiVL9j"
-&amp;gt; (define wif/uncomp "5KDwznXNT8sJbhtYheFNB1ho9Yb69hfJGgmTkW9cNVBr7LxFEje")
-&amp;gt; (wif-&amp;gt;addr wif/uncomp)
"15YzfXwEg5STm3GtEh87LAyzNbpVpdx5eN"
&lt;/code&gt;&lt;/pre&gt;
 &lt;h3 id="software"&gt;Software&lt;/h3&gt;
 &lt;p&gt;All the code from this post &lt;a href="http://www.lostintransaction.com/code/priv2addr.rkt"&gt;is available here&lt;/a&gt;. In this post, I&amp;rsquo;m using Racket 6.0.0.3 running in Debian 7.0, and MultiBit 0.5.17 running in Windows 7 64-bit.&lt;/p&gt;&lt;/html&gt;</description></item>
  <item>
   <title>Computing a Bitcoin Address, Part 3: Base58Check Encoding</title>
   <link>http://www.lostintransaction.com/blog/2014/03/18/computing-a-bitcoin-address-part-3-base58check-encoding/?utm_source=all&amp;utm_medium=RSS</link>
   <guid>urn:http-www-lostintransaction-com:-blog-2014-03-18-computing-a-bitcoin-address-part-3-base58check-encoding</guid>
   <pubDate>Tue, 18 Mar 2014 05:44:11 UTC</pubDate>
   <description>
&lt;html&gt;&lt;img src="http://www.lostintransaction.com/img/1x1.gif?utm_source=all&amp;amp;utm_medium=RSS&amp;amp;utm_campaign=%2Fblog%2F2014%2F03%2F18%2Fcomputing-a-bitcoin-address-part-3-base58check-encoding%2F" height="1" width="1" /&gt;
 &lt;p&gt;In previous posts, we looked at &lt;a href="http://www.lostintransaction.com/blog/2014/03/14/computing-a-bitcoin-address-part-1-private-to-public-key/" title="Computing a Bitcoin Address, Part 1: Private to Public Key"&gt;computing a Bitcoin public key from a private key&lt;/a&gt;, and &lt;a href="http://www.lostintransaction.com/blog/2014/03/15/computing-a-bitcoin-address-part-2-public-key-to-hex-address/" title="Computing a Bitcoin Address, Part 2: Public Key to (Hex) Address"&gt;computing a Bitcoin address from a public key&lt;/a&gt;. However, these posts dealt with keys and addresses in hexadecimal (hex) form, which is not the representation familiar to most Bitcoin users. Bitcoin addresses more commonly are encoded as &lt;a href="https://en.bitcoin.it/wiki/Base58Check_encoding" title="Base58Check encoding"&gt;Base58Check&lt;/a&gt; strings, which we explore in this post.&lt;/p&gt;
 &lt;blockquote&gt;
  &lt;p&gt;This is the third post in a four-part series titled &amp;ldquo;Computing a Bitcoin Address&amp;rdquo;. Here are all the articles in the series:&lt;/p&gt;
  &lt;ul&gt;
   &lt;li&gt;Part 1: &lt;a href="http://www.lostintransaction.com/blog/2014/03/14/computing-a-bitcoin-address-part-1-private-to-public-key/"&gt;Private to Public Key&lt;/a&gt;&lt;/li&gt;
   &lt;li&gt;Part 2: &lt;a href="http://www.lostintransaction.com/blog/2014/03/15/computing-a-bitcoin-address-part-2-public-key-to-hex-address/"&gt;Public Key to (Hex) Address&lt;/a&gt;&lt;/li&gt;
   &lt;li&gt;Part 3: &lt;a href="http://www.lostintransaction.com/blog/2014/03/18/computing-a-bitcoin-address-part-3-base58check-encoding/"&gt;Base58Check Encoding&lt;/a&gt; (this post)&lt;/li&gt;
   &lt;li&gt;Part 4: &lt;a href="http://www.lostintransaction.com/blog/2014/04/09/computing-a-bitcoin-address-part-4-wallet-import-format-wif/"&gt;Wallet Import Format (WIF)&lt;/a&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/blockquote&gt;
 &lt;p&gt;The &lt;a href="https://github.com/bitcoin/bitcoin/blob/f76c122e2eac8ef66f69d142231bd33c88a24c50/src/base58.h#L7-L12" title="src/base58.h"&gt;Bitcoin reference code&lt;/a&gt; provides the following rationale for using Base58Check (instead of a more common base&amp;ndash;64 encoding):&lt;/p&gt;
 &lt;pre&gt;&lt;code&gt;// Why base-58 instead of standard base-64 encoding?
// - Don't want 0OIl characters that look the same in some fonts and
//      could be used to create visually identical looking account numbers.
// - A string with non-alphanumeric characters is not as easily accepted as an account number.
// - E-mail usually won't line-break if there's no punctuation to break at.
// - Double-clicking selects the whole number as one word if it's all alphanumeric.&lt;/code&gt;&lt;/pre&gt;
 &lt;p&gt;Essentially, the goal with Base58Check is to make it easier for humans to read and handle Bitcoin addresses. In this post, instead of the C++ used in the Bitcoin reference, we implement Base58Check encoding and decoding using &lt;a href="http://racket-lang.org"&gt;Racket&lt;/a&gt;, which lets us avoid the hassle of dealing with &lt;code&gt;BIGNUM&lt;/code&gt; numbers.&lt;/p&gt;
 &lt;h3 id="encoding"&gt;Encoding&lt;/h3&gt;
 &lt;p&gt;To convert a hex string to Base58Check, we need to repeatedly perform modulo and division operations on the string. However, Racket doesn&amp;rsquo;t come with modulo and division operations on hex strings so it&amp;rsquo;ll be easier to convert to a base&amp;ndash;10 number first. Here&amp;rsquo;s a Racket function &lt;code&gt;hex-str-&amp;gt;num&lt;/code&gt; that converts from hex to base&amp;ndash;10.&lt;/p&gt;
 &lt;pre class="brush: racket"&gt;&lt;code&gt;(define HEX-CHARS "0123456789ABCDEF")

; case-insensitive character equality operator
(define (anycase=? c1 c2) (char=? (char-upcase c1) (char-upcase c2)))

; convert hex digit to base-10 number
(define (hex-char-&amp;gt;num ch)
  (define index 
    (for/first ([(c n) (in-indexed HEX-CHARS)] #:when (anycase=? c ch)) n))
  (or index (error 'hex-char-&amp;gt;num "invalid hex char: ~a\n" ch)))
      
; convert hex string to base-10 number
(define (hex-str-&amp;gt;num hstr)
  (for/fold ([num 0]) ([ch (in-string hstr)]) 
    (+ (* 16 num) (hex-char-&amp;gt;num ch))))&lt;/code&gt;&lt;/pre&gt;
 &lt;p&gt;The &lt;code&gt;fold/for&lt;/code&gt; form defines an intermediate result &lt;code&gt;num&lt;/code&gt; that is initially 0 and then for each hex character in the input &lt;code&gt;hstr&lt;/code&gt;, multiplies the intermediate result by 16 and adds to it the base&amp;ndash;10 representation of that hex character, as computed by &lt;code&gt;hex-char-&amp;gt;num&lt;/code&gt;. The &lt;code&gt;hex-char-&amp;gt;num&lt;/code&gt; function converts a hex character to a number by computing the position of the character in the &lt;code&gt;HEX-CHARS&lt;/code&gt; constant string (or throws an error if the input character is not valid hex). Note that &lt;code&gt;hex-char-&amp;gt;num&lt;/code&gt; accepts both upper and lowercase hex characters, and uses the case-insensitive &lt;code&gt;anycase=?&lt;/code&gt; to compare characters for equality.&lt;/p&gt;
 &lt;p&gt;Let&amp;rsquo;s see what the (hex) Bitcoin address from &lt;a href="https://en.bitcoin.it/wiki/Technical_background_of_version_1_Bitcoin_addresses" title="Technical background of version 1 Bitcoin addresses"&gt;this Bitcoin Wiki article&lt;/a&gt; (step 8) is in base&amp;ndash;10 (the above code is saved to a file &lt;code&gt;base58.rkt&lt;/code&gt; with &lt;code&gt;hex-str-&amp;gt;num&lt;/code&gt; exported):&lt;/p&gt;
 &lt;pre&gt;&lt;code&gt;$ racket
Welcome to Racket v6.0.0.3.
-&amp;gt; (require "base58.rkt")
-&amp;gt; (hex-str-&amp;gt;num "00010966776006953D5567439E5E39F86A0D273BEED61967F6")
25420294593250030202636073700053352635053786165627414518&lt;/code&gt;&lt;/pre&gt;
 &lt;p&gt;We can now use standard (base&amp;ndash;10) modulo and divide operations to convert from base&amp;ndash;10 to Base58Check. Here&amp;rsquo;s an initial attempt at converting to base&amp;ndash;58:&lt;/p&gt;
 &lt;pre class="brush: racket"&gt;&lt;code&gt;(define BASE58-CHARS "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz")

; convert base10 number to base58 digit
(define (num-&amp;gt;base58-char n)
  (when (or (&amp;lt; n 0) (&amp;gt;= n 58))
    (error 'num-&amp;gt;base58-char "cannot convert to base-58: ~a\n" n))
  (string-ref BASE58-CHARS n))
  
;; convert base10 number to base58check string (first attempt)
(define (num-&amp;gt;base58-str.v0 n)
  (list-&amp;gt;string
    (reverse
      (let loop ([n n])
        (define-values (q r) (quotient/remainder n 58))
        (if (zero? q)
            (list (num-&amp;gt;base58-char r))
            (cons (num-&amp;gt;base58-char r) (loop q)))))))

; convert hex string to base58check string (first attempt)
(define (hex-str-&amp;gt;base58-str.v0 hstr) 
  (num-&amp;gt;base58-str.v0 (hex-str-&amp;gt;num hstr)))&lt;/code&gt;&lt;/pre&gt;
 &lt;p&gt;The &lt;code&gt;hex-str-&amp;gt;base58-str.v0&lt;/code&gt; function first converts its hex string input to a base&amp;ndash;10 number using the previously defined &lt;code&gt;hex-str-&amp;gt;num&lt;/code&gt;. It then calls &lt;code&gt;num-&amp;gt;base58-str.v0&lt;/code&gt; to convert the base&amp;ndash;10 number to base&amp;ndash;58. The &lt;code&gt;num-&amp;gt;base58-str.v0&lt;/code&gt; function repeatedly performs &lt;code&gt;modulo 58&lt;/code&gt; and integer division operations on the given number &amp;mdash; the &lt;code&gt;quotient/remainder&lt;/code&gt; Racket function conveniently performs both these operations in one step. Passing the &lt;code&gt;modulo&lt;/code&gt; result (ie the remainder &lt;code&gt;r&lt;/code&gt;) to &lt;code&gt;num-&amp;gt;base58-char&lt;/code&gt; gives the next base&amp;ndash;58 digit and the division result (ie the quotient &lt;code&gt;q&lt;/code&gt;) is used in the next &lt;code&gt;loop&lt;/code&gt; iteration. The end result of the &lt;code&gt;loop&lt;/code&gt; is a list of base&amp;ndash;58 digits. The digits are computed in reverse order so they are reversed before converting back to a string.&lt;/p&gt;
 &lt;p&gt;Let&amp;rsquo;s test our code. Following &lt;a href="https://en.bitcoin.it/wiki/Technical_background_of_version_1_Bitcoin_addresses" title="Technical background of version 1 Bitcoin addresses"&gt;the same example from the Bitcoin wiki&lt;/a&gt;, the hex address &lt;code&gt;00010966776006953D5567439E5E39F86A0D273BEED61967F6&lt;/code&gt; should be &lt;code&gt;16UwLL9Risc3QfPqBUvKofHmBQ7wMtjvM&lt;/code&gt; in Base58Check.&lt;/p&gt;
 &lt;pre&gt;&lt;code&gt;$ racket
Welcome to Racket v6.0.0.3.
-&amp;gt; (require "base58.rkt")
-&amp;gt; (hex-str-&amp;gt;base58-str.v0 "00010966776006953D5567439E5E39F86A0D273BEED61967F6")
"6UwLL9Risc3QfPqBUvKofHmBQ7wMtjvM"&lt;/code&gt;&lt;/pre&gt;
 &lt;p&gt;Our initial attempt produces the wrong answer! What happened? It turns out that the leading zeros in a hex string matter when the string is viewed as a Bitcoin address. But when we converted to base&amp;ndash;10, the leading zeros got dropped since they don&amp;rsquo;t matter for numbers.&lt;/p&gt;
 &lt;p&gt;To fix the base&amp;ndash;58 conversion, following the Bitcoin reference code, we count the number of leading zeros in the hex string and add one leading &amp;lsquo;1&amp;rsquo; character to the base&amp;ndash;58 address for each leading zero &lt;em&gt;byte&lt;/em&gt; in the hex string, ie, we add one leading base&amp;ndash;58 &amp;lsquo;1&amp;rsquo; per two leading hex &amp;rsquo;0&amp;rsquo;s. Here&amp;rsquo;s an updated conversion function:&lt;/p&gt;
 &lt;pre class="brush: racket"&gt;&lt;code&gt;(define (count-leading-zeros str)
  (for/sum ([c (in-string str)] #:break (not (char=? #\0 c))) 1))

; converts base10 number to base58check string
(define (num-&amp;gt;base58-str n) 
  (if (zero? n) "" (num-&amp;gt;base58-str.v0 n)))
  
; converts hex string to base58check string
(define (hex-str-&amp;gt;base58-str hstr)
  (define num-leading-ones (quotient (count-leading-zeros hstr) 2))
  (define leading-ones (make-string num-leading-ones #\1))
  (string-append leading-ones (num-&amp;gt;base58-str (hex-str-&amp;gt;num hstr))))&lt;/code&gt;&lt;/pre&gt;
 &lt;p&gt;Trying our example again yields the expected result:&lt;/p&gt;
 &lt;pre&gt;&lt;code&gt;$ racket
Welcome to Racket v6.0.0.3.
-&amp;gt; (require "base58.rkt")
-&amp;gt; (hex-str-&amp;gt;base58-str "00010966776006953D5567439E5E39F86A0D273BEED61967F6")
"16UwLL9Risc3QfPqBUvKofHmBQ7wMtjvM"&lt;/code&gt;&lt;/pre&gt;
 &lt;h3 id="decoding"&gt;Decoding&lt;/h3&gt;
 &lt;p&gt;To convert from base&amp;ndash;58 back to hex, we reverse the above steps. We first convert from base&amp;ndash;58 to base&amp;ndash;10 and then from base&amp;ndash;10 to hex.&lt;/p&gt;
 &lt;p&gt;The conversion from base&amp;ndash;58 strings into base&amp;ndash;10 numbers looks a lot like the &lt;code&gt;hex-str-&amp;gt;num&lt;/code&gt; and &lt;code&gt;hex-char-&amp;gt;num&lt;/code&gt; functions we defined above:&lt;/p&gt;
 &lt;pre class="brush: racket"&gt;&lt;code&gt;; converts base58check digit to base10 number
(define (base58-char-&amp;gt;num ch)
  (define index
    (for/first ([(c n) (in-indexed BASE58-CHARS)] #:when (char=? c ch)) n))
  (or index (error 'base58-char-&amp;gt;num "invalid base58 char: ~a\n" ch)))

; converts base58check string to base10 number
(define (base58-str-&amp;gt;num b58str)
  (for/fold ([num 0]) ([ch (in-string b58str)])
    (+ (* 58 num) (base58-char-&amp;gt;num ch))))&lt;/code&gt;&lt;/pre&gt;
 &lt;p&gt;Note that unlike &lt;code&gt;hex-char-&amp;gt;num&lt;/code&gt;, &lt;code&gt;base58-char-&amp;gt;num&lt;/code&gt; is case-sensitive.&lt;/p&gt;
 &lt;p&gt;Similarly, the conversion from base&amp;ndash;10 to hex looks mostly like the &lt;code&gt;num-&amp;gt;base58-str&lt;/code&gt; function above:&lt;/p&gt;
 &lt;pre class="brush: racket"&gt;&lt;code&gt;; convert base10 number to hex digit
(define (num-&amp;gt;hex-char n)
  (when (or (&amp;lt; n 0) (&amp;gt;= n 16))
    (error 'num-&amp;gt;hex-char "cannot convert to hex: ~a\n" n))
  (string-ref HEX-CHARS n))

; convert base10 number to hex string
(define (num-&amp;gt;hex-str n)
  (if (zero? n) ""
      (list-&amp;gt;string
        (reverse
          (let loop ([n n])
            (define-values (q r) (quotient/remainder n 16))
            (if (zero? q)
                (list (num-&amp;gt;hex-char r))
                (cons (num-&amp;gt;hex-char r) (loop q))))))))&lt;/code&gt;&lt;/pre&gt;
 &lt;p&gt;Putting it all together gives us a &lt;code&gt;base58-str-&amp;gt;hex-str&lt;/code&gt; decoding function. This time we don&amp;rsquo;t forget to count the leading digits, &amp;lsquo;1&amp;rsquo;s here instead of &amp;rsquo;0&amp;rsquo;s. Note that we add an extra &amp;rsquo;0&amp;rsquo; to odd-length hex strings so the result is always byte-aligned.&lt;/p&gt;
 &lt;pre class="brush: racket"&gt;&lt;code&gt;(define (count-leading-ones str)
  (for/sum ([c (in-string str)] #:break (not (char=? #\1 c))) 1))
  
; converts a base58check string to a hex string
(define (base58-str-&amp;gt;hex-str b58str)
  (define hex-str/no-leading-zeros (num-&amp;gt;hex-str (base58-str-&amp;gt;num b58str)))
  (define num-leading-ones (count-leading-ones b58str))
  (define num-leading-zeros
    (if (even? (string-length hex-str/no-leading-zeros))
        (* num-leading-ones 2)
        (add1 (* num-leading-ones 2)))) ; add extra 0 to byte-align
  (define leading-zeros (make-string num-leading-zeros #\0))
  (string-append leading-zeros hex-str/no-leading-zeros))&lt;/code&gt;&lt;/pre&gt;
 &lt;p&gt;And trying it on our &lt;a href="https://en.bitcoin.it/wiki/Technical_background_of_version_1_Bitcoin_addresses" title="Technical background of version 1 Bitcoin addresses"&gt;example&lt;/a&gt; returns the expected results (the &lt;code&gt;^&lt;/code&gt; token in the &lt;a href="http://docs.racket-lang.org/xrepl/index.html"&gt;Racket Extended REPL&lt;/a&gt; is bound to the last printed value):&lt;/p&gt;
 &lt;pre&gt;&lt;code&gt;$ racket
Welcome to Racket v6.0.0.3.
-&amp;gt; (require "base58.rkt")
-&amp;gt; (define addr/hex "00010966776006953D5567439E5E39F86A0D273BEED61967F6")
-&amp;gt; (hex-str-&amp;gt;base58-str addr/hex)
"16UwLL9Risc3QfPqBUvKofHmBQ7wMtjvM"
-&amp;gt; (define addr/base58 ^)
-&amp;gt; (base58-str-&amp;gt;hex-str ^)
"00010966776006953D5567439E5E39F86A0D273BEED61967F6"
-&amp;gt; (equal? addr/hex ^)
#t
-&amp;gt; (equal? (base58-str-&amp;gt;hex-str (hex-str-&amp;gt;base58-str addr/hex)) addr/hex)
#t
-&amp;gt; (equal? (hex-str-&amp;gt;base58-str (base58-str-&amp;gt;hex-str addr/base58)) addr/base58)
#t&lt;/code&gt;&lt;/pre&gt;
 &lt;h3 id="software"&gt;Software&lt;/h3&gt;
 &lt;p&gt;All the code from this post &lt;a href="http://www.lostintransaction.com/code/base58.rkt"&gt;is available here&lt;/a&gt;. Examples were executed with Racket 6.0.0.3, running in Debian 7.0.&lt;/p&gt;&lt;/html&gt;</description></item>
  <item>
   <title>Computing a Bitcoin Address, Part 2: Public Key to (Hex) Address</title>
   <link>http://www.lostintransaction.com/blog/2014/03/15/computing-a-bitcoin-address-part-2-public-key-to-hex-address/?utm_source=all&amp;utm_medium=RSS</link>
   <guid>urn:http-www-lostintransaction-com:-blog-2014-03-15-computing-a-bitcoin-address-part-2-public-key-to-hex-address</guid>
   <pubDate>Sat, 15 Mar 2014 04:09:45 UTC</pubDate>
   <description>
&lt;html&gt;&lt;img src="http://www.lostintransaction.com/img/1x1.gif?utm_source=all&amp;amp;utm_medium=RSS&amp;amp;utm_campaign=%2Fblog%2F2014%2F03%2F15%2Fcomputing-a-bitcoin-address-part-2-public-key-to-hex-address%2F" height="1" width="1" /&gt;
 &lt;p&gt;In a previous post, we &lt;a href="http://www.lostintransaction.com/blog/2014/03/14/computing-a-bitcoin-address-part-1-private-to-public-key/" title="Computing a Bitcoin Address, Part 1: Private to Public Key"&gt;derived a Bitcoin public key from a private key&lt;/a&gt;. This post explores how to convert that public key into a (hexadecimal) Bitcoin address. I&amp;rsquo;ll be using &lt;a href="http://racket-lang.org"&gt;the Racket language&lt;/a&gt; to help me.&lt;/p&gt;
 &lt;blockquote&gt;
  &lt;p&gt;This is the second post in a four-part series titled &amp;ldquo;Computing a Bitcoin Address&amp;rdquo;. Here are all the articles in the series:&lt;/p&gt;
  &lt;ul&gt;
   &lt;li&gt;Part 1: &lt;a href="http://www.lostintransaction.com/blog/2014/03/14/computing-a-bitcoin-address-part-1-private-to-public-key/"&gt;Private to Public Key&lt;/a&gt;&lt;/li&gt;
   &lt;li&gt;Part 2: &lt;a href="http://www.lostintransaction.com/blog/2014/03/15/computing-a-bitcoin-address-part-2-public-key-to-hex-address/"&gt;Public Key to (Hex) Address&lt;/a&gt; (this post)&lt;/li&gt;
   &lt;li&gt;Part 3: &lt;a href="http://www.lostintransaction.com/blog/2014/03/18/computing-a-bitcoin-address-part-3-base58check-encoding/"&gt;Base58Check Encoding&lt;/a&gt;&lt;/li&gt;
   &lt;li&gt;Part 4: &lt;a href="http://www.lostintransaction.com/blog/2014/04/09/computing-a-bitcoin-address-part-4-wallet-import-format-wif/"&gt;Wallet Import Format (WIF)&lt;/a&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/blockquote&gt;
 &lt;p&gt;To convert from a public key to a Bitcoin address, we need an implementation of the &lt;a href="http://en.wikipedia.org/wiki/SHA-2" title="Wikipedia: SHA-2"&gt;SHA&amp;ndash;256&lt;/a&gt; and &lt;a href="http://en.wikipedia.org/wiki/RIPEMD" title="Wikipedia: RIPEMD"&gt;RIPEMD&amp;ndash;160&lt;/a&gt; hash functions. Racket doesn&amp;rsquo;t come with these functions but we can easily call to OpenSSL&amp;rsquo;s implementation of these functions via Racket&amp;rsquo;s C &lt;a href="http://docs.racket-lang.org/foreign/index.html" title="Racket FFI"&gt;FFI&lt;/a&gt;.&lt;/p&gt;
 &lt;p&gt;Conveniently, the standard Racket distribution already defines &lt;a href="https://github.com/plt/racket/blob/master/racket/collects/openssl/libcrypto.rkt" title="Racket source: libcrypto.rkt"&gt;a hook into the &lt;code&gt;libcrypto&lt;/code&gt; library&lt;/a&gt;, also named &lt;code&gt;libcrypto&lt;/code&gt;. Racket comes with wrapper functions for some &lt;code&gt;libcrypto&lt;/code&gt; C functions, but not &lt;code&gt;SHA256&lt;/code&gt; or &lt;code&gt;RIPEMD160&lt;/code&gt; so let&amp;rsquo;s create those.&lt;/p&gt;
 &lt;p&gt;Here&amp;rsquo;s the header for the &lt;a href="http://git.openssl.org/gitweb/?p=openssl.git;a=blob;f=crypto/sha/sha.h;h=8a6bf4bbbb1dbef37869fc162ce1c2cacfebeb1d;hb=46ebd9e3bb623d3c15ef2203038956f3f7213620#l155" title="OpenSSL source: crypto/sha/sha.h"&gt;&lt;code&gt;SHA256&lt;/code&gt; C function&lt;/a&gt;:&lt;/p&gt;
 &lt;pre class="brush: C"&gt;&lt;code&gt;unsigned char *SHA256( const unsigned char *d, size_t n, unsigned char *md );&lt;/code&gt;&lt;/pre&gt;
 &lt;p&gt;We use the Racket &lt;a href="http://docs.racket-lang.org/foreign/Loading_Foreign_Libraries.html?q=get-ffi-obj#%28def._%28%28lib._ffi%2Funsafe..rkt%29._get-ffi-obj%29%29" title="Racket docs: get-ffi-obj"&gt;&lt;code&gt;get-ffi-obj&lt;/code&gt;&lt;/a&gt; function to create a Racket wrapper for &lt;code&gt;SHA256&lt;/code&gt;. Here&amp;rsquo;s a Racket &lt;code&gt;sha256&lt;/code&gt; function that calls the C &lt;code&gt;SHA256&lt;/code&gt; function:&lt;/p&gt;
 &lt;pre class="brush: racket"&gt;&lt;code&gt;(define SHA256-DIGEST-LEN 32) ; bytes

(define sha256
  (get-ffi-obj 'SHA256 libcrypto
    (_fun [input     : _bytes]
          [input-len : _ulong = (bytes-length input)]
          [output    : (_bytes o SHA256-DIGEST-LEN)]
          -&amp;gt; (_bytes o SHA256-DIGEST-LEN))))&lt;/code&gt;&lt;/pre&gt;
 &lt;p&gt;The first argument to &lt;code&gt;get-ffi-obj&lt;/code&gt; is the name of the C function and the second argument is the hook into the appropriate library. The third argument is the type, which specifies how to mediate between Racket and C values. &lt;a href="http://docs.racket-lang.org/foreign/foreign_procedures.html?q=_fun#%28form._%28%28lib._ffi%2Funsafe..rkt%29.__fun%29%29" title="Racket docs: _fun"&gt;&lt;code&gt;_fun&lt;/code&gt;&lt;/a&gt; is the function type and in this case the function has three arguments (each delimited with brackets by convention).&lt;/p&gt;
 &lt;p&gt;Examining the types of the arguments:&lt;/p&gt;
 &lt;ol&gt;
  &lt;li&gt;
   &lt;p&gt;The first argument to the &lt;code&gt;SHA256&lt;/code&gt; C function is an array of input bytes. Accordingly, we give &lt;code&gt;get-ffi-obj&lt;/code&gt; a &lt;code&gt;_bytes&lt;/code&gt; type for this argument.&lt;/p&gt;&lt;/li&gt;
  &lt;li&gt;
   &lt;p&gt;The second argument is the length of the input byte array. The &lt;code&gt;=&lt;/code&gt; and the expression following it describe how to calculate this argument automatically. Thus a caller of &lt;code&gt;sha256&lt;/code&gt; does not provide this argument.&lt;/p&gt;&lt;/li&gt;
  &lt;li&gt;
   &lt;p&gt;The third argument is the output byte array. The &lt;code&gt;o&lt;/code&gt; indicates a return pointer and is followed by the expected length of the output array, which should be 32 bytes here. We define a constant &lt;code&gt;SHA256-DIGEST-LEN&lt;/code&gt; which is analogous to &lt;a href="http://git.openssl.org/gitweb/?p=openssl.git;a=blob;f=crypto/sha/sha.h;h=8a6bf4bbbb1dbef37869fc162ce1c2cacfebeb1d;hb=46ebd9e3bb623d3c15ef2203038956f3f7213620#l133" title="OpenSSL source: crypto/sha/sha.h"&gt;the &lt;code&gt;SHA256_DIGEST_LENGTH&lt;/code&gt; constant&lt;/a&gt; in the C library.&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;
 &lt;p&gt;Similarly, here&amp;rsquo;s a definition for a Racket &lt;code&gt;ripemd160&lt;/code&gt; function:&lt;/p&gt;
 &lt;pre class="brush: racket"&gt;&lt;code&gt;(define RIPEMD160-DIGEST-LEN 20) ; bytes

; from crypto/ripemd/ripemd.h:
;  unsigned char *RIPEMD160(const unsigned char *d, size_t n, unsigned char *md);
(define ripemd160
  (get-ffi-obj 'RIPEMD160 libcrypto
    (_fun [input     : _bytes]
          [input-len : _ulong = (bytes-length input)]
          [output    : (_bytes o RIPEMD160-DIGEST-LEN)]
          -&amp;gt; (_bytes o RIPEMD160-DIGEST-LEN))))&lt;/code&gt;&lt;/pre&gt;
 &lt;h3 id="testing"&gt;Testing&lt;/h3&gt;
 &lt;p&gt;To test our wrapper functions, let&amp;rsquo;s see if we can duplicate &lt;a href="https://en.bitcoin.it/wiki/Technical_background_of_version_1_Bitcoin_addresses" title="Bitcoin Wiki: Technical background of version 1 Bitcoin addresses"&gt;this example from the Bitcoin wiki&lt;/a&gt;, which shows how to convert a Bitcoin private key into a public address. We covered &lt;a href="http://www.lostintransaction.com/blog/2014/03/14/computing-a-bitcoin-address-part-1-private-to-public-key/" title="Computing a Bitcoin Address, Part 1: Private to Public Key"&gt;how to derive a public key from a private key&lt;/a&gt; in a previous post, so we start with the public key here.&lt;/p&gt;
 &lt;p&gt;For ease of comparison, here&amp;rsquo;s the sequence of expected hashes, copied from the Bitcoin wiki example:&lt;/p&gt;
 &lt;ol&gt;
  &lt;li&gt;public key: &lt;code&gt;0450863AD64A87AE8A2FE83C1AF1A8403CB53F53E486D8511DAD8A04887E5B23522CD470243453A299FA9E77237716103ABC11A1DF38855ED6F2EE187E9C582BA6&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;SHA&amp;ndash;256: &lt;code&gt;600FFE422B4E00731A59557A5CCA46CC183944191006324A447BDB2D98D4B408&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;RIPEMD&amp;ndash;160: &lt;code&gt;010966776006953D5567439E5E39F86A0D273BEE&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;prepend &lt;code&gt;0x00&lt;/code&gt;: &lt;code&gt;00010966776006953D5567439E5E39F86A0D273BEE&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;SHA&amp;ndash;256: &lt;code&gt;445C7A8007A93D8733188288BB320A8FE2DEBD2AE1B47F0F50BC10BAE845C094&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;SHA&amp;ndash;256 (checksum is first 4 bytes): &lt;code&gt;D61967F63C7DD183914A4AE452C9F6AD5D462CE3D277798075B107615C1A8A30&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;step 4 result + checksum = (hex) address: &lt;code&gt;00010966776006953D5567439E5E39F86A0D273BEED61967F6&lt;/code&gt;&lt;/li&gt;&lt;/ol&gt;
 &lt;p&gt;The hashes are all in hexdecimal form so we extend our hash functions to convert to and from hex strings (&lt;code&gt;bytes-&amp;gt;hex-string&lt;/code&gt; and &lt;code&gt;hex-string-&amp;gt;bytes&lt;/code&gt; are built-in Racket functions):&lt;/p&gt;
 &lt;pre class="brush: racket"&gt;&lt;code&gt;(define (sha256/hex input)
  (bytes-&amp;gt;hex-string (sha256 (hex-string-&amp;gt;bytes input))))
  
(define (ripemd160/hex input)
  (bytes-&amp;gt;hex-string (ripemd160 (hex-string-&amp;gt;bytes input))))&lt;/code&gt;&lt;/pre&gt;
 &lt;p&gt;Now we can duplicate the sequence of hashes from the example, using the &lt;a href="http://www.lostintransaction.com/code/crypto.rkt"&gt;code from this post&lt;/a&gt; (saved to a file &lt;code&gt;crypto.rkt&lt;/code&gt;) and &lt;a href="http://docs.racket-lang.org/xrepl/index.html" title="XREPL"&gt;the Racket (extended) REPL&lt;/a&gt; (the &lt;code&gt;^&lt;/code&gt; token in the REPL represents the last printed result):&lt;/p&gt;
 &lt;pre&gt;&lt;code&gt;$ racket
Welcome to Racket v6.0.0.3.
-&amp;gt; (require "crypto.rkt")
-&amp;gt; (define pub-key "0450863AD64A87AE8A2FE83C1AF1A8403CB53F53E486D8511DAD8A04887E5B23522CD470243453A299FA9E77237716103ABC11A1DF38855ED6F2EE187E9C582BA6")
-&amp;gt; (sha256/hex pub-key)
"600ffe422b4e00731a59557a5cca46cc183944191006324a447bdb2d98d4b408"
-&amp;gt; (ripemd160/hex ^)
"010966776006953d5567439e5e39f86a0d273bee"
-&amp;gt; (string-append "00" ^)
"00010966776006953d5567439e5e39f86a0d273bee"
-&amp;gt; (define version0+hash160 ^)
-&amp;gt; (sha256/hex ^)
"445c7a8007a93d8733188288bb320a8fe2debd2ae1b47f0f50bc10bae845c094"
-&amp;gt; (sha256/hex ^)
"d61967f63c7dd183914a4ae452c9f6ad5d462ce3d277798075b107615c1a8a30"
-&amp;gt; (substring ^ 0 8) ; checksum
"d61967f6"
-&amp;gt; (string-append version0+hash160 ^)
"00010966776006953d5567439e5e39f86a0d273beed61967f6"
   &lt;/code&gt;&lt;/pre&gt;
 &lt;p&gt;The final result is the Bitcoin address from the example, in hexadecimal format. The Bitcoin wiki article performs one more step to convert to &lt;a href="https://en.bitcoin.it/wiki/Base58Check_encoding" title="Bitcoin wiki: Base58Check encoding"&gt;Base58Check encoding&lt;/a&gt;, which is the standard representation for Bitcoin addresses. We&amp;rsquo;ll look at Base58Check encoding in the next post!&lt;/p&gt;
 &lt;h3 id="software"&gt;Software&lt;/h3&gt;
 &lt;p&gt;All the code from this post &lt;a href="http://www.lostintransaction.com/code/crypto.rkt"&gt;is available here&lt;/a&gt;. In this post, I&amp;rsquo;m using OpenSSL 1.0.1e with Racket 6.0.0.3, running in Debian 7.0.&lt;/p&gt;&lt;/html&gt;</description></item>
  <item>
   <title>Computing a Bitcoin Address, Part 1: Private to Public Key</title>
   <link>http://www.lostintransaction.com/blog/2014/03/14/computing-a-bitcoin-address-part-1-private-to-public-key/?utm_source=all&amp;utm_medium=RSS</link>
   <guid>urn:http-www-lostintransaction-com:-blog-2014-03-14-computing-a-bitcoin-address-part-1-private-to-public-key</guid>
   <pubDate>Fri, 14 Mar 2014 05:28:01 UTC</pubDate>
   <description>
&lt;html&gt;&lt;img src="http://www.lostintransaction.com/img/1x1.gif?utm_source=all&amp;amp;utm_medium=RSS&amp;amp;utm_campaign=%2Fblog%2F2014%2F03%2F14%2Fcomputing-a-bitcoin-address-part-1-private-to-public-key%2F" height="1" width="1" /&gt;
 &lt;p&gt;I&amp;rsquo;ve been wondering how Bitcoin addresses are generated. This post and the ones following will explore, step by step, how to transform a Bitcoin private key to a public address.&lt;/p&gt;
 &lt;p&gt;I know that Bitcoin public and private keys are &lt;a href="http://en.wikipedia.org/wiki/Elliptic_Curve_DSA" title="Wikipedia: Elliptic Curve DSA"&gt;Elliptic Curve DSA (ECDSA)&lt;/a&gt; key pairs, and I&amp;rsquo;ve seen the &lt;a href="http://stackoverflow.com/questions/12480776/how-do-i-obtain-the-public-key-from-an-ecdsa-private-key-in-openssl" title="Stack Overflow: Public Key from Private Key"&gt;&lt;code&gt;Q = dG&lt;/code&gt; explanation&lt;/a&gt; on a few sites, but they leave out some details. I want to experiment for myself, so this post describes how to derive a public key from a private key with runnable code.&lt;/p&gt;
 &lt;blockquote&gt;
  &lt;p&gt;This is the first post in a four-part series titled &amp;ldquo;Computing a Bitcoin Address&amp;rdquo;.  Here are all the articles in the series:&lt;/p&gt;
  &lt;ul&gt;
   &lt;li&gt;Part 1: &lt;a href="http://www.lostintransaction.com/blog/2014/03/14/computing-a-bitcoin-address-part-1-private-to-public-key/"&gt;Private to Public Key&lt;/a&gt; (this post)&lt;/li&gt;
   &lt;li&gt;Part 2: &lt;a href="http://www.lostintransaction.com/blog/2014/03/15/computing-a-bitcoin-address-part-2-public-key-to-hex-address/"&gt;Public Key to (Hex) Address&lt;/a&gt;&lt;/li&gt;
   &lt;li&gt;Part 3: &lt;a href="http://www.lostintransaction.com/blog/2014/03/18/computing-a-bitcoin-address-part-3-base58check-encoding/"&gt;Base58Check Encoding&lt;/a&gt;&lt;/li&gt;
   &lt;li&gt;Part 4: &lt;a href="http://www.lostintransaction.com/blog/2014/04/09/computing-a-bitcoin-address-part-4-wallet-import-format-wif/"&gt;Wallet Import Format (WIF)&lt;/a&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/blockquote&gt;
 &lt;p&gt;The &lt;a href="http://stackoverflow.com/a/12482384/951881" title="Stack Overflow: Public Key from Private Key Answer"&gt;accepted Stack Overflow answer from the linked elliptic curve question above&lt;/a&gt; says that in the &lt;code&gt;Q = dG&lt;/code&gt; equation, &lt;code&gt;Q&lt;/code&gt; is the public key and &lt;code&gt;d&lt;/code&gt; is the private key, but does not explain &lt;code&gt;G&lt;/code&gt;, the group parameter. Luckily, some Googling quickly finds that Bitcoin uses the &lt;a href="https://en.bitcoin.it/wiki/Secp256k1" title="secp256k1 Bitcoin wiki entry"&gt;&lt;code&gt;secp256k1&lt;/code&gt; ECDSA curve&lt;/a&gt;.&lt;/p&gt;
 &lt;p&gt;Next, I looked at the &lt;a href="https://www.openssl.org/" title="OpenSSL"&gt;OpenSSL&lt;/a&gt; &lt;code&gt;libcrypto&lt;/code&gt; C library, in &lt;a href="http://git.openssl.org/gitweb/?p=openssl.git;a=blob;f=crypto/ec/ec_key.c;h=7fa247593d91b45347704e62e184e1138fc8bd01;hb=46ebd9e3bb623d3c15ef2203038956f3f7213620#l236" title="crypto/ec/ec_key.c"&gt;&lt;code&gt;EC_KEY_generate_key&lt;/code&gt; (the function mentioned in the Stack Overflow post)&lt;/a&gt;. Here&amp;rsquo;s the line that performs the multiplication:&lt;/p&gt;
 &lt;pre class="brush: c"&gt;&lt;code&gt;EC_POINT_mul(eckey-&amp;gt;group, pub_key, priv_key, NULL, NULL, ctx);&lt;/code&gt;&lt;/pre&gt;
 &lt;p&gt;In this case, I&amp;rsquo;m supplying &lt;code&gt;priv_key&lt;/code&gt;, and &lt;code&gt;pub_key&lt;/code&gt; is the output parameter, so I just need the appropriate group for the first parameter. OpenSSL has &lt;a href="http://git.openssl.org/gitweb/?p=openssl.git;a=blob;f=crypto/objects/obj_mac.h;h=b5ea7cdab4f84b90280f0a3aae1478a8d715c7a7;hb=46ebd9e3bb623d3c15ef2203038956f3f7213620#l385" title="crypto/objects/obj_mac.h"&gt;already defined the &lt;code&gt;secp256k1&lt;/code&gt; curve&lt;/a&gt;, so it&amp;rsquo;s just a matter of getting the right data representation. Here is the &lt;a href="http://git.openssl.org/gitweb/?p=openssl.git;a=blob;f=crypto/ec/ec.h;h=dfe8710d330954bb1762a5fe13d655ac7a5f01be;hb=46ebd9e3bb623d3c15ef2203038956f3f7213620#l643" title="crypto/ec/ec.h"&gt;header for &lt;code&gt;EC_POINT_mul&lt;/code&gt;&lt;/a&gt; from the OpenSSL library:&lt;/p&gt;
 &lt;pre class="brush: c"&gt;&lt;code&gt;/** Computes r = generator * n + q * m
 *  \param  group  underlying EC_GROUP object
 *  \param  r      EC_POINT object for the result
 *  \param  n      BIGNUM with the multiplier for the group generator (optional)
 *  \param  q      EC_POINT object with the first factor of the second summand
 *  \param  m      BIGNUM with the second factor of the second summand
 *  \param  ctx    BN_CTX object (optional)
 *  \return 1 on success and 0 if an error occured
 */
int EC_POINT_mul(const EC_GROUP *group, EC_POINT *r, const BIGNUM *n, const EC_POINT *q, const BIGNUM *m, BN_CTX *ctx);&lt;/code&gt;&lt;/pre&gt;
 &lt;p&gt;Looks like we need an &lt;code&gt;EC_GROUP&lt;/code&gt;. To create one we call &lt;a href="http://git.openssl.org/gitweb/?p=openssl.git;a=blob;f=crypto/ec/ec_curve.c;h=c72fb2697ca2823a4aac36b027012bed6c457288;hb=46ebd9e3bb623d3c15ef2203038956f3f7213620#l2057" title="crypco/ec/ec_curve.c"&gt;&lt;code&gt;EC_GROUP_new_by_curve_name&lt;/code&gt;&lt;/a&gt;.&lt;/p&gt;
 &lt;p&gt;Putting everything together, here&amp;rsquo;s a function &lt;code&gt;priv2pub&lt;/code&gt; that computes a public key from a private key (disclaimer: the code has no error-checking so don&amp;rsquo;t use this in production):&lt;/p&gt;
 &lt;pre class="brush: c"&gt;&lt;code&gt;// calculates and returns the public key associated with the given private key
// - input private key and output public key are in hexadecimal
// form = POINT_CONVERSION_[UNCOMPRESSED|COMPRESSED|HYBRID]
unsigned char *priv2pub( const unsigned char *priv_hex,
                         point_conversion_form_t form )
{
  // create group
  EC_GROUP *ecgrp = EC_GROUP_new_by_curve_name( NID_secp256k1 );
  
  // convert priv key from hexadecimal to BIGNUM
  BIGNUM *priv_bn = BN_new();
  BN_hex2bn( &amp;amp;priv_bn, priv_hex );
  
  // compute pub key from priv key and group
  EC_POINT *pub = EC_POINT_new( ecgrp );
  EC_POINT_mul( ecgrp, pub, priv_bn, NULL, NULL, NULL );
                           
  // convert pub_key from elliptic curve coordinate to hexadecimal
  unsigned char *ret = EC_POINT_point2hex( ecgrp, pub, form, NULL );
 
  EC_GROUP_free( ecgrp ); BN_free( priv_bn ); EC_POINT_free( pub );
  
  return ret;
}&lt;/code&gt;&lt;/pre&gt;
 &lt;p&gt;The function assumes that the input private key is in hex, and returned public key is in hex as well. I had to first convert the private key to &lt;code&gt;BIGNUM&lt;/code&gt;, which is OpenSSL&amp;rsquo;s number representation for arbitrary precision arithmetic. The computed public key is an OpenSSL &lt;code&gt;EC_POINT&lt;/code&gt; data structure, which represents a curve coordinate. The curve coordinate is converted back to hex using &lt;code&gt;EC_POINT_point2hex&lt;/code&gt;. &lt;a href="https://en.bitcoin.it/wiki/Elliptic_Curve_Digital_Signature_Algorithm" title="Bitcoin Wiki: Elliptic Curve Digital Signature Algorithm"&gt;Public keys can either be compressed or uncompressed&lt;/a&gt;, and the format of the output of &lt;code&gt;priv2pub&lt;/code&gt; depends on the &lt;code&gt;form&lt;/code&gt; input parameter, &lt;a href="http://git.openssl.org/gitweb/?p=openssl.git;a=blob;f=crypto/ec/ec.h;h=dfe8710d330954bb1762a5fe13d655ac7a5f01be;hb=46ebd9e3bb623d3c15ef2203038956f3f7213620#l104" title="crypto/ec/ec.h"&gt;which can be one of three values&lt;/a&gt;.&lt;/p&gt;
 &lt;p&gt;To test this function, I found a sample public/private key pair from &lt;a href="https://en.bitcoin.it/wiki/Technical_background_of_version_1_Bitcoin_addresses" title="Bitcoin wiki: technical explanation of addresses"&gt;this Bitcoin wiki article&lt;/a&gt;. The private key from the article is &lt;code&gt;18E14A7B6A307F426A94F8114701E7C8E774E7F9A47E2C2035DB29A206321725&lt;/code&gt; and the public key is &lt;code&gt;0450863AD64A87AE8A2FE83C1AF1A8403CB53F53E486D8511DAD8A04887E5B23522CD470243453A299FA9E77237716103ABC11A1DF38855ED6F2EE187E9C582BA6&lt;/code&gt;. The public key begins with &lt;code&gt;0x04&lt;/code&gt; &lt;a href="http://www.secg.org/collateral/sec1.pdf" title="SEC: Elliptic Curve Cryptography"&gt;so we know it&amp;rsquo;s in uncompressed form (see section 2.3.3)&lt;/a&gt; and is 65 bytes long (see ANSI X9.62 for more details).&lt;/p&gt;
 &lt;p&gt;I used the following &lt;code&gt;main&lt;/code&gt; function to test if &lt;code&gt;priv2pub&lt;/code&gt; can compute the public key using the private key from the example:&lt;/p&gt;
 &lt;pre class="brush: c"&gt;&lt;code&gt;int main( int argc, const unsigned char *argv[] )
{
  // get priv key from cmd line and compute pub key
  unsigned char *pub_hex = priv2pub( argv[1], POINT_CONVERSION_UNCOMPRESSED );
  
  printf( "%s\n", pub_hex );
 
  free( pub_hex );
  
  return 0;
}&lt;/code&gt;&lt;/pre&gt;
 &lt;p&gt;I save the code above to a file &lt;code&gt;priv2pub.c&lt;/code&gt;:&lt;/p&gt;
 &lt;pre&gt;&lt;code&gt;$ gcc -lcrypto -std=c99 priv2pub.c -o priv2pub
$ ./priv2pub 18E14A7B6A307F426A94F8114701E7C8E774E7F9A47E2C2035DB29A206321725
0450863AD64A87AE8A2FE83C1AF1A8403CB53F53E486D8511DAD8A04887E5B23522CD470243453A299FA9E77237716103ABC11A1DF38855ED6F2EE187E9C582BA6&lt;/code&gt;&lt;/pre&gt;
 &lt;p&gt;Success!&lt;/p&gt;
 &lt;p&gt;Let&amp;rsquo;s try another example. I generated a private key with &lt;a href="https://www.bitaddress.org"&gt;bitaddress.org&lt;/a&gt;, &lt;code&gt;5JQZaZrYCbJ1Kb96vFBMEefrQGuNfHSqbHbviC3URUNGJ27frFe&lt;/code&gt;, but it&amp;rsquo;s in &lt;a href="https://en.bitcoin.it/wiki/Base58Check_encoding" title="Bitcoin wiki: Base58Check encoding"&gt;Base58Check encoding&lt;/a&gt; and not hex. We&amp;rsquo;ll deal with Base58 encoding later so for now I went to the &amp;ldquo;Wallet Details&amp;rdquo; tab at &lt;a href="https://www.bitaddress.org"&gt;bitaddress.org&lt;/a&gt;, entered the base58 key, and found that the private key in hex is &lt;code&gt;4DD3D47E491C5D34F9540EBF3444E3D6675015A46B61AF37B4EB7F17DDDF4E61&lt;/code&gt; and the public key is &lt;code&gt;0492EDC09A7311C2AB83EF3D133331D7B73117902BB391D9DAC3BE261547F571E171F16775DDA6D09A6AAF1F3F6E6AA3CFCD854DCAA6AED0FA7AF9A5ED9965E117&lt;/code&gt;. Let&amp;rsquo;s check what our code says:&lt;/p&gt;
 &lt;pre&gt;&lt;code&gt;$ ./priv2pub 4DD3D47E491C5D34F9540EBF3444E3D6675015A46B61AF37B4EB7F17DDDF4E61
0492EDC09A7311C2AB83EF3D133331D7B73117902BB391D9DAC3BE261547F571E171F16775DDA6D09A6AAF1F3F6E6AA3CFCD854DCAA6AED0FA7AF9A5ED9965E117&lt;/code&gt;&lt;/pre&gt;
 &lt;p&gt;Hurrah!&lt;/p&gt;
 &lt;h3 id="a-racket-version"&gt;A Racket Version&lt;/h3&gt;
 &lt;p&gt;I&amp;rsquo;m using &lt;a href="http://racket-lang.org"&gt;Racket&lt;/a&gt;, a modern LISP dialect, to experiment with Bitcoin so I want a Racket version of my conversion function as well. Fortunately, Racket has an &lt;a href="http://docs.racket-lang.org/foreign/index.html" title="Racket FFI"&gt;FFI&lt;/a&gt; that enables Racket code to call C functions directly.&lt;/p&gt;
 &lt;p&gt;First I create a slightly different version of my C function:&lt;/p&gt;
 &lt;pre class="brush: c"&gt;&lt;code&gt;// calculates and returns the public key associated with the given private key
// - input private key is in hexadecimal
// - output public key is in raw bytes
// form = POINT_CONVERSION_[UNCOMPRESSED|COMPRESSED|HYBRID]
unsigned char *priv2pub_bytes( const unsigned char *priv_hex,
                               point_conversion_form_t form,
                               unsigned char *ret )
{
  // create group
  EC_GROUP *ecgrp = EC_GROUP_new_by_curve_name( NID_secp256k1 );
  
  // convert priv key from hexadecimal to BIGNUM
  BIGNUM *priv_bn = BN_new();
  BN_hex2bn( &amp;amp;priv_bn, priv_hex );
  
  // compute pub key from priv key and group
  EC_POINT *pub = EC_POINT_new( ecgrp );
  EC_POINT_mul( ecgrp, pub, priv_bn, NULL, NULL, NULL );
  
  // convert pub key from elliptic curve coordinate to bytes
  //  (first call gets the appropriate length to use)
  size_t len = EC_POINT_point2oct( ecgrp, pub, form, NULL, 0, NULL );
  EC_POINT_point2oct( ecgrp, pub, form, ret, len, NULL );
        
  EC_GROUP_free( ecgrp ); BN_free( priv_bn ); EC_POINT_free( pub );
  
  return ret;
}&lt;/code&gt;&lt;/pre&gt;
 &lt;p&gt;The difference is an extra parameter and the representation of the public key output. This new function uses &lt;code&gt;EC_POINT_point2oct&lt;/code&gt; to return a byte string instead of a hex string. The problem is that the hex conversion function, &lt;code&gt;EC_POINT_point2hex&lt;/code&gt;, allocates, but I don&amp;rsquo;t want to manually manage memory in Racket. Because &lt;code&gt;priv2pub_bytes&lt;/code&gt; consumes an additional buffer parameter, Racket can allocate a buffer controlled by the GC prior to calling the function, and then pass in this allocated buffer.&lt;/p&gt;
 &lt;p&gt;Next I use Racket&amp;rsquo;s FFI to create a Racket wrapper function for the &lt;code&gt;priv2pub_bytes&lt;/code&gt; C function. The FFI requires a library file, so I compile the &lt;code&gt;.c&lt;/code&gt; file to a &lt;code&gt;.so&lt;/code&gt; library.&lt;/p&gt;
 &lt;pre&gt;&lt;code&gt;$ gcc -lcrypto -std=c99 -fPIC -shared -Wl,-soname,libpriv2pub.so.1 priv2pub.c -o libpriv2pub.so.1.0
&lt;/code&gt;&lt;/pre&gt;
 &lt;p&gt;This creates a dynamic library file named &lt;code&gt;libpriv2pub.so.1.0&lt;/code&gt;.&lt;/p&gt;
 &lt;p&gt;To create a Racket value for this library, we use the Racket &lt;code&gt;ffi-lib&lt;/code&gt; function:&lt;/p&gt;
 &lt;pre class="brush: racket"&gt;&lt;code&gt;(define-runtime-path libpriv2pub-so '(so "libpriv2pub"))

(define libpriv2pub (ffi-lib libpriv2pub-so '("1.0")))&lt;/code&gt;&lt;/pre&gt;
 &lt;p&gt;The first argument to &lt;code&gt;ffi-lib&lt;/code&gt; is the path of the library and the second argument specifies a list of acceptable version numbers.&lt;/p&gt;
 &lt;p&gt;Once we have a hook into the C library, we can create Racket wrappers for individual functions in the library. We use the Racket &lt;code&gt;get-ffi-obj&lt;/code&gt; function to do this:&lt;/p&gt;
 &lt;pre class="brush: racket"&gt;&lt;code&gt;(define UNCOMPRESSED-LEN 65)
(define priv2pub_bytes
  (get-ffi-obj 'priv2pub_bytes libpriv2pub
    (_fun _string _int (_bytes o UNCOMPRESSED-LEN)
          -&amp;gt; (_bytes o UNCOMPRESSED-LEN))))&lt;/code&gt;&lt;/pre&gt;
 &lt;p&gt;This creates a Racket function &lt;code&gt;priv2pub_bytes&lt;/code&gt; where the first argument is a (Racket) string, the second is an integer indicating whether the output should be in compressed or uncompressed form, and the third is the output buffer. A pointer to the output buffer is also returned by the function. We make the size the output buffer equal to the uncompressed form since that is the maximum size.&lt;/p&gt;
 &lt;p&gt;Let&amp;rsquo;s make things easier to use with a couple more functions:&lt;/p&gt;
 &lt;pre class="brush: racket"&gt;&lt;code&gt;(define COMPRESSED 2) ; POINT_CONVERSION_COMPRESSED
(define UNCOMPRESSED 4) ; POINT_CONVERSION_UNCOMPRESSED
(define COMPRESSED-LEN 33)
(define (priv-key-&amp;gt;pub-key/compressed priv/hex)
  (bytes-&amp;gt;hex-string 
    (subbytes (priv2pub_bytes priv/hex COMPRESSED) 0 COMPRESSED-LEN)))
(define (priv-key-&amp;gt;pub-key priv/hex)
  (bytes-&amp;gt;hex-string 
    (priv2pub_bytes priv/hex UNCOMPRESSED)))&lt;/code&gt;&lt;/pre&gt;
 &lt;p&gt;&lt;code&gt;priv-key-&amp;gt;pub-key&lt;/code&gt; consumes a private key in hex and returns an uncompressed public key, also in hex. &lt;code&gt;priv-key-&amp;gt;pub-key/compressed&lt;/code&gt; is similar except it returns a compressed public key (note that this function extracts only the first 33 bytes of the output buffer).&lt;/p&gt;
 &lt;p&gt;Testing our examples again, with &lt;a href="http://docs.racket-lang.org/xrepl/index.html" title="XREPL"&gt;the Racket (extended) REPL&lt;/a&gt;, we see that our Racket functions produce the same results:&lt;/p&gt;
 &lt;pre&gt;&lt;code&gt;$ racket
Welcome to Racket v6.0.0.3.
-&amp;gt; (require "priv2pub.rkt")
-&amp;gt; (priv-key-&amp;gt;pub-key "18E14A7B6A307F426A94F8114701E7C8E774E7F9A47E2C2035DB29A206321725")
"0450863ad64a87ae8a2fe83c1af1a8403cb53f53e486d8511dad8a04887e5b23522cd470243453a299fa9e77237716103abc11a1df38855ed6f2ee187e9c582ba6"
-&amp;gt; (priv-key-&amp;gt;pub-key "4DD3D47E491C5D34F9540EBF3444E3D6675015A46B61AF37B4EB7F17DDDF4E61")
"0492edc09a7311c2ab83ef3d133331d7b73117902bb391d9dac3be261547f571e171f16775dda6d09a6aaf1f3f6e6aa3cfcd854dcaa6aed0fa7af9a5ed9965e117"&lt;/code&gt;&lt;/pre&gt;
 &lt;h3 id="software"&gt;Software&lt;/h3&gt;
 &lt;p&gt;The C code from this post &lt;a href="http://www.lostintransaction.com/code/priv2pub.c"&gt;is available here&lt;/a&gt; and the Racket code &lt;a href="http://www.lostintransaction.com/code/priv2pub.rkt"&gt;is available here&lt;/a&gt;. In this post, I&amp;rsquo;m using OpenSSL 1.0.1e and gcc 4.7.2, running in Debian 7.0. I had to install the &lt;code&gt;libssl-dev&lt;/code&gt; package to get the proper header files.&lt;/p&gt;&lt;/html&gt;</description></item>
  <item>
   <title>Verifying Andreas's "Fundraising for Dorian" Message</title>
   <link>http://www.lostintransaction.com/blog/2014/03/07/verifying-andreas-s-fundraising-for-dorian-message/?utm_source=all&amp;utm_medium=RSS</link>
   <guid>urn:http-www-lostintransaction-com:-blog-2014-03-07-verifying-andreas-s-fundraising-for-dorian-message</guid>
   <pubDate>Fri, 07 Mar 2014 18:52:52 UTC</pubDate>
   <description>
&lt;html&gt;&lt;img src="http://www.lostintransaction.com/img/1x1.gif?utm_source=all&amp;amp;utm_medium=RSS&amp;amp;utm_campaign=%2Fblog%2F2014%2F03%2F07%2Fverifying-andreas-s-fundraising-for-dorian-message%2F" height="1" width="1" /&gt;
 &lt;p&gt;Today, Andreas M. Antonopoulos, Chief Security Officer of Blockchain.info, started a &lt;a href="http://www.reddit.com/r/Bitcoin/comments/1ztjmg/andreas_im_fundraising_for_dorian_nakamoto/" title="Dorian fundraiser message on Reddit"&gt;fundraiser&lt;/a&gt; for Dorian Nakamoto, the guy who&amp;rsquo;s being harassed by the media due to Newsweek&amp;rsquo;s recent article about Satoshi Nakamoto. To prove that the message is not fake, Andreas &lt;a href="http://pastebin.com/4MHvpaeN" title="Dorian fundraiser message on Pastebin"&gt;signed the message&lt;/a&gt; with his public key. Since I&amp;rsquo;ve &lt;a href="http://www.lostintransaction.com/blog/2014/03/05/verifying-hashes-and-signatures/" title="Post: Verifying Hashes and Signatures"&gt;recently been playing with digital signatures&lt;/a&gt;, this seemed like a great chance to explore some more. Let&amp;rsquo;s try to to verify the message.&lt;/p&gt;
 &lt;p&gt;Unlike, &lt;a href="http://www.lostintransaction.com/blog/2014/03/05/verifying-hashes-and-signatures/" title="Post: Verifying Hashes and Signatures"&gt;when we wanted to verify the Multibit signature&lt;/a&gt;, Andreas posted a &lt;a href="http://gnupg.org/gph/en/manual/x135.html" title="GnuPG docs"&gt;clearsigned&lt;/a&gt; message, where the content and signature are in the same document. However, we can still use &lt;a href="http://www.gnupg.org/" title="GnuPG"&gt;GnuPG&lt;/a&gt; to verify the message.&lt;/p&gt;
 &lt;p&gt;First, we need Andreas&amp;rsquo;s public key. I went to the &lt;a href="http://pgp.mit.edu/"&gt;MIT PGP Public Key Server&lt;/a&gt; and &lt;a href="http://pgp.mit.edu/pks/lookup?search=%22Andreas+M.+Antonopoulos%22&amp;amp;op=index" title="Andreas PGP key search results"&gt;searched for &lt;code&gt;"Andreas M. Antonopoulos"&lt;/code&gt;&lt;/a&gt;. There were several results, so I arbitrarily chose the one associated with his domain name:&lt;/p&gt;
 &lt;pre&gt;&lt;code&gt;pub  4096R/2878DE4F 2013-12-14 Andreas M. Antonopoulos &amp;lt;andreas@antonopoulos.com&amp;gt;&lt;/code&gt;&lt;/pre&gt;
 &lt;p&gt;I then added the key to my database:&lt;/p&gt;
 &lt;pre&gt;&lt;code&gt;$ gpg2.exe" --keyserver pgp.mit.edu --recv-keys 0x2878DE4F
gpg: requesting key 2878DE4F from hkp server pgp.mit.edu
gpg: key 2878DE4F: public key "Andreas M. Antonopoulos &amp;lt;andreas@antonopoulos.com&amp;gt;" imported
gpg: Total number processed: 1
gpg:               imported: 1  (RSA: 1)&lt;/code&gt;&lt;/pre&gt;
 &lt;p&gt;Next, I downloaded the &lt;a href="http://pastebin.com/download.php?i=4MHvpaeN" title="download message txt file"&gt;message from Pastebin&lt;/a&gt; and tried to verify it:&lt;/p&gt;
 &lt;pre&gt;&lt;code&gt;$gpg2.exe" --verify andreas_fundraising_for_dorian.txt
gpg: Signature made 03/07/14 12:26:34 Eastern Standard Time using RSA key ID B1632E74
gpg: Can't check signature: No public key&lt;/code&gt;&lt;/pre&gt;
 &lt;p&gt;Oops, I got the wrong key. The message is signed with key &lt;code&gt;B1632E74&lt;/code&gt; (Andreas&amp;rsquo;s Blockchain.info key) so let&amp;rsquo;s get that one:&lt;/p&gt;
 &lt;pre&gt;&lt;code&gt;$ gpg2.exe" --keyserver pgp.mit.edu --recv-keys 0xB1632E74
gpg: requesting key B1632E74 from hkp server pgp.mit.edu
gpg: key B1632E74: public key "Andreas M. Antonopoulos (Blockchain.info CSO) &amp;lt;andreas@blockchain.info&amp;gt;" imported
gpg: no ultimately trusted keys found
gpg: Total number processed: 1
gpg:               imported: 1  (RSA: 1)&lt;/code&gt;&lt;/pre&gt;
 &lt;p&gt;And now let&amp;rsquo;s try to verify:&lt;/p&gt;
 &lt;pre&gt;&lt;code&gt;$ gpg2.exe" --verify andreas_fundraising_for_dorian.txt
gpg: Signature made 03/07/14 12:26:34 Eastern Standard Time using RSA key ID B1632E74
gpg: Good signature from "Andreas M. Antonopoulos (Blockchain.info CSO) &amp;lt;andreas@blockchain.info&amp;gt;"
gpg: WARNING: This key is not certified with a trusted signature!
gpg:          There is no indication that the signature belongs to the owner.
Primary key fingerprint: B40F E0EB 4316 82F5 A7BD  5B3B 339B 0210 B163 2E74&lt;/code&gt;&lt;/pre&gt;
 &lt;p&gt;Success!&lt;/p&gt;
 &lt;p&gt;One final issue. How do we know that &lt;em&gt;the&lt;/em&gt; Andreas Antonopoulos actually controls the &lt;code&gt;B1632E74&lt;/code&gt; key, and not someone posing as him, or someone else with the same name. As I mentioned in a &lt;a href="http://www.lostintransaction.com/blog/2014/03/05/verifying-hashes-and-signatures/" title="Post: Verifying Hashes and Signatures"&gt;previous post&lt;/a&gt;, there&amp;rsquo;s a few options:&lt;/p&gt;
 &lt;ol&gt;
  &lt;li&gt;
   &lt;p&gt;We can look in a central place that we trust. I checked &lt;a href="https://bitcoin.org/en"&gt;bitcoin.org&lt;/a&gt; and found the &lt;a href="https://bitcoin.org/en/development"&gt;PGP keys for several important people&lt;/a&gt; in the Bitcoin community. But no Andreas! I could not find anything on &lt;a href="https://blockchain.info"&gt;blockchain.info&lt;/a&gt; either.&lt;/p&gt;&lt;/li&gt;
  &lt;li&gt;
   &lt;p&gt;We can do an informal verification via &amp;ldquo;public consensus&amp;rdquo; by looking at &lt;a href="http://pgp.mit.edu/pks/lookup?op=vindex&amp;amp;search=0x339B0210B1632E74" title="Andreas Antonopoulos public key signatures"&gt;who else signed Andreas&amp;rsquo;s key&lt;/a&gt;. Unfortunately, there are not too many other signatures at the moment:&lt;/p&gt;
   &lt;pre&gt;&lt;code&gt;uid Andreas M. Antonopoulos (Blockchain.info CSO) &amp;lt;andreas@blockchain.info&amp;gt;
sig  sig3  B1632E74 2014-01-22 __________ 2015-01-22 [selfsig]
sig  sig   2878DE4F 2014-01-22 __________ __________ Andreas M. Antonopoulos &amp;lt;andreas@antonopoulos.com&amp;gt;
sig  sig   CF8338F5 2014-03-07 __________ __________ Christopher David Howie &amp;lt;me@chrishowie.com&amp;gt;&lt;/code&gt;&lt;/pre&gt;
   &lt;p&gt;Other than Andreas himself, there&amp;rsquo;s only one other person that is vouching for the key.&lt;/p&gt;&lt;/li&gt;
  &lt;li&gt;Luckily, Andreas anticipated this issue, and &lt;a href="http://www.youtube.com/watch?v=JCF1u1Wqfv0" title="Andreas PGP key YouTube video"&gt;issued a statement on YouTube&lt;/a&gt;, confirming his key. It&amp;rsquo;s a match! Now we are assured that the message is authentic.&lt;/li&gt;&lt;/ol&gt;
 &lt;h3 id="software"&gt;Software&lt;/h3&gt;
 &lt;p&gt;In this post, I used GnuPG 2.0.22 (Gpgwin 2.2.1) and libgcrypt 1.5.3, running in Windows 7 64-bit.&lt;/p&gt;&lt;/html&gt;</description></item>
  <item>
   <title>Verifying Hashes and Signatures</title>
   <link>http://www.lostintransaction.com/blog/2014/03/05/verifying-hashes-and-signatures/?utm_source=all&amp;utm_medium=RSS</link>
   <guid>urn:http-www-lostintransaction-com:-blog-2014-03-05-verifying-hashes-and-signatures</guid>
   <pubDate>Wed, 05 Mar 2014 06:44:02 UTC</pubDate>
   <description>
&lt;html&gt;&lt;img src="http://www.lostintransaction.com/img/1x1.gif?utm_source=all&amp;amp;utm_medium=RSS&amp;amp;utm_campaign=%2Fblog%2F2014%2F03%2F05%2Fverifying-hashes-and-signatures%2F" height="1" width="1" /&gt;
 &lt;p&gt;Security is really important when handling bitcoins. Hashes and signatures can help by verifying that you&amp;rsquo;re downloading what you think you&amp;rsquo;re downloading.&lt;/p&gt;
 &lt;p&gt;In this post, I briefly explain hashes and signatures, and then check the hash and signature of the MultiBit wallet program, essentially following &lt;a href="https://multibit.org/blog/2013/07/24/how-to-check-signatures.html" title="MultiBit tutorial on hashes and signatures"&gt;the MultiBit tutorial on hashes and signatures&lt;/a&gt;. All examples are run in Windows 7 (64-bit).&lt;/p&gt;
 &lt;h3 id="verifying-hashes"&gt;Verifying Hashes&lt;/h3&gt;
 &lt;h4 id="a-first-example"&gt;&lt;em&gt;A first example&lt;/em&gt;&lt;/h4&gt;
 &lt;p&gt;A hash function maps its input to a number. Any hash function may map various different inputs to the same number, but for certain &lt;a href="http://en.wikipedia.org/wiki/Cryptographic_hash_function" title="cryptographic hash function Wikipedia entry"&gt;&lt;em&gt;cryptographic&lt;/em&gt; hash functions&lt;/a&gt;, the probability of collision is so small that we can treat the hash function&amp;rsquo;s output as a unique identifier for the given input. The &lt;a href="http://en.wikipedia.org/wiki/SHA-1" title="SHA-1 Wikipedia entry"&gt;SHA&amp;ndash;1&lt;/a&gt; cryptographic hash function maps inputs to 160-bit numbers (40 hexadecimal digits). Here&amp;rsquo;s the SHA&amp;ndash;1 hash (computed with Microsoft&amp;rsquo;s FCIV program) of the &lt;code&gt;"Hello world"&lt;/code&gt; example from the MultiBit tutorial:&lt;/p&gt;
 &lt;pre&gt;&lt;code&gt;$ echo "Hello world" &amp;gt; example.txt
$ fciv -sha1 example.txt
//
// File Checksum Integrity Verifier version 2.05.
//
25e64db6d4d1d6116ffe0b317918c98f3624cbed example.txt&lt;/code&gt;&lt;/pre&gt;
 &lt;p&gt;Note that in Windows, the resulting hash differs from the tutorial (ie, when using Linux) because the generated Windows &lt;code&gt;examples.txt&lt;/code&gt; file has extra quotes, an extra space, and uses the windows &lt;code&gt;\r\n&lt;/code&gt; end-of-line instead of &lt;code&gt;\n&lt;/code&gt;. We can easily simulate the Linux version though, to get the same hash from the tutorial. Here I use a &lt;a href="http://racket-lang.org"&gt;Racket&lt;/a&gt; script:&lt;/p&gt;
 &lt;pre class="brush: racket"&gt;&lt;code&gt;(with-output-to-file "example.txt" (lambda () (display "Hello world\n")) #:exists 'replace)&lt;/code&gt;&lt;/pre&gt;
 &lt;pre&gt;&lt;code&gt;$ racket
Welcome to Racket v6.0.0.3
&amp;gt; (with-output-to-file "example.txt" (lambda () (display "Hello world\n")) #:exists 'replace)
&amp;gt; (exit)
$ fciv -sha1 example.txt
//
// File Checksum Integrity Verifier version 2.05.
//
33ab5639bfd8e7b95eb1d8d0b87781d4ffea4d5d example.txt
&lt;/code&gt;&lt;/pre&gt;
 &lt;p&gt;The output now matches the tutorial. &lt;a href="http://bitcoin.stackexchange.com/questions/14041/multibit-error-or-at-least-confusion-in-how-to-check-digital-signatures-in" title="Bitcoin StackExchange"&gt;It looks like I&amp;rsquo;m not the only person to notice the discrepancy&lt;/a&gt;.&lt;/p&gt;
 &lt;h4 id="computing-sha256"&gt;&lt;em&gt;Computing SHA&amp;ndash;256&lt;/em&gt;&lt;/h4&gt;
 &lt;p&gt;Most software you download from the internet should provide a hash that you can verify to make sure the file was not corrupted or altered. For example, Multibit provides &lt;a href="http://en.wikipedia.org/wiki/SHA-2" title="SHA-256 Wikipedia entry"&gt;SHA&amp;ndash;256 hashes&lt;/a&gt; (256-bit output) in &lt;a href="https://multibit.org/releases/multibit-0.5.17/release.txt" title="MultiBit 0.5.17 release notes"&gt;the release notes&lt;/a&gt; (SHA&amp;ndash;256 is also the main hash function used in the &lt;a href="https://en.bitcoin.it/wiki/Protocol_specification#Common_standards" title="Bitcoin protocol"&gt;Bitcoin protocol&lt;/a&gt;).&lt;/p&gt;
 &lt;p&gt;Since FCIV only computes SHA&amp;ndash;1, we need something else that computes SHA&amp;ndash;256. A quick Google search finds the &lt;a href="http://md5deep.sourceforge.net/"&gt;&lt;code&gt;md5deep&lt;/code&gt; library&lt;/a&gt;.&lt;/p&gt;
 &lt;p&gt;Since we are emphasizing security, let&amp;rsquo;s first make sure the program we just got is virus-free by &lt;a href="https://www.virustotal.com/en/file/eec0c765124b014c824db8759300f36b4a62b74ff81dfa68f77440389bb68d29/analysis/" title="sha256deep64.exe on virustotal"&gt;uploading to VirusTotal&lt;/a&gt;.&lt;/p&gt;
 &lt;p&gt;VirusTotal also uses SHA&amp;ndash;256, to track which files it has seen, and we can check that the file we uploaded, &lt;code&gt;sha256deep64.exe&lt;/code&gt;, matches the file for which VirusTotal is reporting results, by running it on itself:&lt;/p&gt;
 &lt;pre&gt;&lt;code&gt;$ sha256deep64 sha256deep64.exe
eec0c765124b014c824db8759300f36b4a62b74ff81dfa68f77440389bb68d29  sha256deep64.exe&lt;/code&gt;&lt;/pre&gt;
 &lt;p&gt;Interestingly, &lt;code&gt;sha256deep64.exe&lt;/code&gt; and &lt;code&gt;sha1deep64.exe&lt;/code&gt; produce the same SHA&amp;ndash;256 hash:&lt;/p&gt;
 &lt;pre&gt;&lt;code&gt;$ sha256deep64 sha1deep64.exe
eec0c765124b014c824db8759300f36b4a62b74ff81dfa68f77440389bb68d29  sha1deep64.exe&lt;/code&gt;&lt;/pre&gt;
 &lt;p&gt;No cause for concern though. Apparently this is &lt;a href="http://sourceforge.net/projects/md5deep/reviews/?offset=25" title="explanation of identical hash"&gt;intentional&lt;/a&gt; and the file determines its behavior based on its filename.&lt;/p&gt;
 &lt;h4 id="checking-multibits-hash"&gt;&lt;em&gt;Checking MultiBit&amp;rsquo;s hash&lt;/em&gt;&lt;/h4&gt;
 &lt;p&gt;Now we&amp;rsquo;re finally ready to check the hash of the MultiBit program, specifically version 0.5.17 for Windows.&lt;/p&gt;
 &lt;p&gt;From the &lt;a href="https://multibit.org/releases/multibit-0.5.17/release.txt" title="MultiBit 0.5.17 release notes"&gt;release notes&lt;/a&gt;:&lt;/p&gt;
 &lt;pre&gt;&lt;code&gt;SHA256 hashes for files:
90506bf43a64986ce8219ca0fb18a5e1f0776cfeb31043ca848cea7f71eda45d  multibit-0.5.17-windows-setup.exe&lt;/code&gt;&lt;/pre&gt;
 &lt;p&gt;Computing the hash of the downloaded file:&lt;/p&gt;
 &lt;pre&gt;&lt;code&gt;$ sha256deep64 multibit-0.5.17-windows-setup.exe
90506bf43a64986ce8219ca0fb18a5e1f0776cfeb31043ca848cea7f71eda45d  multibit-0.5.17-windows-setup.exe&lt;/code&gt;&lt;/pre&gt;
 &lt;p&gt;And it matches!&lt;/p&gt;
 &lt;h3 id="verifying-signatures"&gt;Verifying Signatures&lt;/h3&gt;
 &lt;h4 id="a-very-brief-introduction"&gt;&lt;em&gt;A very brief introduction&lt;/em&gt;&lt;/h4&gt;
 &lt;p&gt;Verifying the hash only ensures that nothing happened to the file during the download. For example, you can be pretty sure that no one intercepted your download and then sent you a hacked version. But what if the website you downloaded from was hacked in the first place, so both the file and the hash were fake?&lt;/p&gt;
 &lt;p&gt;This is where &lt;a href="http://en.wikipedia.org/wiki/Digital_signature" title="digital signature Wikipedia entry"&gt;digital signatures&lt;/a&gt; can help. Briefly, to prove that a file was not tampered with, the distributor of the file &amp;ldquo;signs&amp;rdquo; the file with a secret key that only they know. The distributor then posts the file, the signature, and a public key that is calculated from the private key. A downloader then uses the public key and signature to verify the downloaded file.&lt;/p&gt;
 &lt;p&gt;In a secure signature system, it&amp;rsquo;s impossible to determine the private key from the public key. Also, the verification process is successful only if the downloaded file was originally signed with the private key, which is known only by the distributor of the file. In other words, in a secure system, it&amp;rsquo;s computationally impossible to forge a valid signature without knowledge of the private key.&lt;/p&gt;
 &lt;h5 id="note"&gt;NOTE:&lt;/h5&gt;
 &lt;p&gt;Verifying a signature does not guarantee that the file you downloaded was not tampered with. If you don&amp;rsquo;t know the person distributing the file, then you might not be able to distinguish between a legitimate file-signature-public-key set from a bad one. However, a reliable signature system often relies on additional knowledge about the public key you are using.&lt;/p&gt;
 &lt;p&gt;For example, the public key could be confirmed by a central authority or key server that does additional checks to link keys to people. Or the other person, and their public key, may be well known, and so the &amp;ldquo;confirmation&amp;rdquo; in this case would be an informal public consensus. None of these methods guarantees authenticity, but they&amp;rsquo;re a lot more difficult to fool.&lt;/p&gt;
 &lt;h4 id="checking-multibits-signature"&gt;&lt;em&gt;Checking MultiBit&amp;rsquo;s signature&lt;/em&gt;&lt;/h4&gt;
 &lt;p&gt;&lt;a href="http://en.wikipedia.org/wiki/Pretty_Good_Privacy" title="PGP Wikipedia entry"&gt;PGP&lt;/a&gt; is a well-known signature system, which we&amp;rsquo;ll use to check verify MultiBit&amp;rsquo;s signature.&lt;/p&gt;
 &lt;ol&gt;
  &lt;li&gt;
   &lt;p&gt;First we download &lt;a href="http://www.gnupg.org/" title="GnuPG"&gt;GnuPG&lt;/a&gt;, &lt;a href="http://www.gnupg.org/" title="GnuPG for Windows"&gt;for Windows&lt;/a&gt;,  specifically Gpg4win-Vanilla, version 2.2.1. Of course we first  check the hash for a match. Here&amp;rsquo;s the hash  &lt;a href="http://www.gpg4win.org/download.html"&gt;from the download page&lt;/a&gt;:&lt;/p&gt;
   &lt;pre&gt;&lt;code&gt;Gpg4win with GnuPG component only: 
SHA1 checksum: 6d229b03ec2dcbb54a40f7590d108dc0cbcb5aac&lt;/code&gt;&lt;/pre&gt;
   &lt;p&gt;And here&amp;rsquo;s the hash of the file I downloaded:&lt;/p&gt;
   &lt;pre&gt;&lt;code&gt;$ sha1deep64 gpg4win-vanilla-2.2.1.exe
6d229b03ec2dcbb54a40f7590d108dc0cbcb5aac  gpg4win-vanilla-2.2.1.exe&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
  &lt;li&gt;
   &lt;p&gt;Then, following the MultiBit tutorial, we get the public key for  Jim Burton, MultiBit developer, from a known key server.&lt;/p&gt;
   &lt;pre&gt;&lt;code&gt;$ gpg2.exe" --keyserver pgp.mit.edu -- recv-keys 0x79F7C572
gpg: requesting key 79F7C572 from hkp server pgp.mit.edu
gpg: .../AppData/Roaming/gnupg/trustdb.gpg: trustdb created
gpg: key 79F7C572: public key "Jim Burton (multibit.org developer) &amp;lt;jim618@fastmail.co.uk&amp;gt;" imported
gpg: no ultimately trusted keys found
gpg: Total number processed: 1
gpg:               imported: 1  (RSA: 1)&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
  &lt;li&gt;
   &lt;p&gt;Then we download the &lt;a href="https://multibit.org/releases/multibit-0.5.17/multibit-0.5.17-windows-setup.exe.asc" title="MultiBit signature file"&gt;signature file&lt;/a&gt;.&lt;/p&gt;&lt;/li&gt;
  &lt;li&gt;
   &lt;p&gt;Finally, we can verify that Jim signed the file we&amp;rsquo;re downloading  and that it hasn&amp;rsquo;t been tampered with.&lt;/p&gt;
   &lt;pre&gt;&lt;code&gt;$ gpg2.exe" --verify multibit-0.5.17-windows-setup.exe.asc
gpg: Signature made 03/03/14 06:09:34 Eastern Standard Time using RSA key ID 23F7FB7B
gpg: Good signature from "Jim Burton (multibit.org developer) &amp;lt;jim618@fastmail.co.uk&amp;gt;"
gpg: WARNING: This key is not certified with a trusted signature!
gpg:          There is no indication that the signature belongs to the owner.
Primary key fingerprint: 299C 423C 672F 47F4 756A  6BA4 C197 2AED 79F7 C572
     Subkey fingerprint: 4A71 A836 F572 01B4 D088  7D60 0820 A658 23F7 FB7B&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;&lt;/ol&gt;
 &lt;p&gt;The warning means that we have never seen Jim&amp;rsquo;s public key, and nor has anyone that we trust (the &lt;code&gt;gpg&lt;/code&gt; program keeps track of people we trust, which is no one at the moment). This key server uses the &lt;a href="http://en.wikipedia.org/wiki/Web_of_trust" title="web of trust Wikipedia entry"&gt;public consensus confirmation strategy&lt;/a&gt; described above. Here, a person&amp;rsquo;s public key can be signed by others and in this way, these other people vouch that this is indeed Jim&amp;rsquo;s key. Of course, it could still be that lots of people have teamed up to deceive you, and have signed a fake version of Jim&amp;rsquo;s key. As the key accumulates more signatures, however, the likelihood that it is fake does down.&lt;/p&gt;
 &lt;h3 id="software"&gt;Software&lt;/h3&gt;
 &lt;p&gt;In this post, I&amp;rsquo;m using MultiBit 0.5.17, GnuPG for Windows 2.2.1, Racket 6.0.0.3, and Windows 7 64-bt.&lt;/p&gt;&lt;/html&gt;</description></item></channel></rss>